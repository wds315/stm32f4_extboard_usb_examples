; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\STM324xG-EVAL\stm32f4xx_i2c.o --asm_dir=.\STM324xG-EVAL\ --list_dir=.\STM324xG-EVAL\ --depend=.\STM324xG-EVAL\stm32f4xx_i2c.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -I..\ -I..\inc -I..\..\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\..\..\Utilities\STM32_EVAL -I..\..\..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F4XX -DUSE_STM324xG_EVAL --omf_browse=.\STM324xG-EVAL\stm32f4xx_i2c.crf ..\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;656      */
;;;657    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;658    {
;;;659      /* Check the parameters */
;;;660      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;661      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;662      if (NewState != DISABLE)
;;;663      {
;;;664        /* Enable the selected I2C ARP */
;;;665        I2Cx->CR1 |= I2C_CR1_ENARP;
;;;666      }
;;;667      else
;;;668      {
;;;669        /* Disable the selected I2C ARP */
;;;670        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L1.12|
000006  f0410110          ORR      r1,r1,#0x10           ;665
00000a  e001              B        |L1.16|
                  |L1.12|
00000c  f0210110          BIC      r1,r1,#0x10
                  |L1.16|
000010  8001              STRH     r1,[r0,#0]            ;665
;;;671      }
;;;672    }
000012  4770              BX       lr
;;;673    /**
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;416      */
;;;417    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;418    {
;;;419      /* Check the parameters */
;;;420      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;421      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;422      if (NewState != DISABLE)
;;;423      {
;;;424        /* Enable the acknowledgement */
;;;425        I2Cx->CR1 |= I2C_CR1_ACK;
;;;426      }
;;;427      else
;;;428      {
;;;429        /* Disable the acknowledgement */
;;;430        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L2.12|
000006  f4416180          ORR      r1,r1,#0x400          ;425
00000a  e001              B        |L2.16|
                  |L2.12|
00000c  f4216180          BIC      r1,r1,#0x400
                  |L2.16|
000010  8001              STRH     r1,[r0,#0]            ;425
;;;431      }
;;;432    }
000012  4770              BX       lr
;;;433    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;793      */
;;;794    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;795    {
;;;796      /* Check the parameters */
;;;797      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;798      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;799      if (NewState != DISABLE)
;;;800      {
;;;801        /* Enable the selected I2C PEC calculation */
;;;802        I2Cx->CR1 |= I2C_CR1_ENPEC;
;;;803      }
;;;804      else
;;;805      {
;;;806        /* Disable the selected I2C PEC calculation */
;;;807        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  f0410120          ORR      r1,r1,#0x20           ;802
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  f0210120          BIC      r1,r1,#0x20
                  |L3.16|
000010  8001              STRH     r1,[r0,#0]            ;802
;;;808      }
;;;809    }
000012  4770              BX       lr
;;;810    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;1096     */
;;;1097   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  8a83              LDRH     r3,[r0,#0x14]
;;;1098   {
;;;1099     uint32_t lastevent = 0;
;;;1100     uint32_t flag1 = 0, flag2 = 0;
;;;1101     ErrorStatus status = ERROR;
000002  2200              MOVS     r2,#0
;;;1102   
;;;1103     /* Check the parameters */
;;;1104     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1105     assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;1106   
;;;1107     /* Read the I2Cx status register */
;;;1108     flag1 = I2Cx->SR1;
;;;1109     flag2 = I2Cx->SR2;
000004  8b00              LDRH     r0,[r0,#0x18]
;;;1110     flag2 = flag2 << 16;
;;;1111   
;;;1112     /* Get the last event value from I2C status register */
;;;1113     lastevent = (flag1 | flag2) & FLAG_MASK;
000006  ea434300          ORR      r3,r3,r0,LSL #16
00000a  f023407f          BIC      r0,r3,#0xff000000
;;;1114   
;;;1115     /* Check whether the last event contains the I2C_EVENT */
;;;1116     if ((lastevent & I2C_EVENT) == I2C_EVENT)
00000e  4381              BICS     r1,r1,r0
000010  d100              BNE      |L4.20|
;;;1117     {
;;;1118       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1119       status = SUCCESS;
000012  2201              MOVS     r2,#1
                  |L4.20|
;;;1120     }
;;;1121     else
;;;1122     {
;;;1123       /* ERROR: last event is different from I2C_EVENT */
;;;1124       status = ERROR;
;;;1125     }
;;;1126     /* Return status */
;;;1127     return status;
000014  4610              MOV      r0,r2
;;;1128   }
000016  4770              BX       lr
;;;1129   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1276     */
;;;1277   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  43c9              MVNS     r1,r1
;;;1278   {
;;;1279     uint32_t flagpos = 0;
;;;1280     /* Check the parameters */
;;;1281     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1282     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1283     /* Get the I2C flag position */
;;;1284     flagpos = I2C_FLAG & FLAG_MASK;
;;;1285     /* Clear the selected I2C flag */
;;;1286     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1287   }
000004  4770              BX       lr
;;;1288   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1370     */
;;;1371   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  43c9              MVNS     r1,r1
;;;1372   {
;;;1373     uint32_t flagpos = 0;
;;;1374     /* Check the parameters */
;;;1375     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1376     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1377   
;;;1378     /* Get the I2C flag position */
;;;1379     flagpos = I2C_IT & FLAG_MASK;
;;;1380   
;;;1381     /* Clear the selected I2C flag */
;;;1382     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1383   }
000004  4770              BX       lr
;;;1384   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;313      */
;;;314    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;315    {
;;;316      /* Check the parameters */
;;;317      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;318      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;319      if (NewState != DISABLE)
;;;320      {
;;;321        /* Enable the selected I2C peripheral */
;;;322        I2Cx->CR1 |= I2C_CR1_PE;
;;;323      }
;;;324      else
;;;325      {
;;;326        /* Disable the selected I2C peripheral */
;;;327        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L7.12|
000006  f0410101          ORR      r1,r1,#1              ;322
00000a  e001              B        |L7.16|
                  |L7.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L7.16|
000010  8001              STRH     r1,[r0,#0]            ;322
;;;328      }
;;;329    }
000012  4770              BX       lr
;;;330    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;848      */
;;;849    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;850    {
;;;851      /* Check the parameters */
;;;852      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;853      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;854      if (NewState != DISABLE)
;;;855      {
;;;856        /* Enable the selected I2C DMA requests */
;;;857        I2Cx->CR2 |= I2C_CR2_DMAEN;
;;;858      }
;;;859      else
;;;860      {
;;;861        /* Disable the selected I2C DMA requests */
;;;862        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L8.12|
000006  f4416100          ORR      r1,r1,#0x800          ;857
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L8.16|
000010  8081              STRH     r1,[r0,#4]            ;857
;;;863      }
;;;864    }
000012  4770              BX       lr
;;;865    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;872      */
;;;873    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;874    {
;;;875      /* Check the parameters */
;;;876      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;877      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;878      if (NewState != DISABLE)
;;;879      {
;;;880        /* Next DMA transfer is the last transfer */
;;;881        I2Cx->CR2 |= I2C_CR2_LAST;
;;;882      }
;;;883      else
;;;884      {
;;;885        /* Next DMA transfer is not the last transfer */
;;;886        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L9.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;881
00000a  e001              B        |L9.16|
                  |L9.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L9.16|
000010  8081              STRH     r1,[r0,#4]            ;881
;;;887      }
;;;888    }
000012  4770              BX       lr
;;;889    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;137      */
;;;138    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  490d              LDR      r1,|L10.56|
;;;139    {
000002  b510              PUSH     {r4,lr}
;;;140      /* Check the parameters */
;;;141      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;142    
;;;143      if (I2Cx == I2C1)
000004  4288              CMP      r0,r1
000006  d102              BNE      |L10.14|
;;;144      {
;;;145        /* Enable I2C1 reset state */
;;;146        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  054c              LSLS     r4,r1,#21
;;;147        /* Release I2C1 from reset state */
;;;148        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
00000c  e00a              B        |L10.36|
                  |L10.14|
;;;149      }
;;;150      else if (I2Cx == I2C2)
00000e  490b              LDR      r1,|L10.60|
000010  4288              CMP      r0,r1
000012  d102              BNE      |L10.26|
;;;151      {
;;;152        /* Enable I2C2 reset state */
;;;153        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000014  2101              MOVS     r1,#1
000016  058c              LSLS     r4,r1,#22
;;;154        /* Release I2C2 from reset state */
;;;155        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
000018  e004              B        |L10.36|
                  |L10.26|
;;;156      }
;;;157      else 
;;;158      {
;;;159        if (I2Cx == I2C3)
00001a  4909              LDR      r1,|L10.64|
00001c  4288              CMP      r0,r1
00001e  d10a              BNE      |L10.54|
;;;160        {
;;;161          /* Enable I2C3 reset state */
;;;162          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
000020  2101              MOVS     r1,#1
000022  05cc              LSLS     r4,r1,#23
                  |L10.36|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;163          /* Release I2C3 from reset state */
;;;164          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
00002a  4620              MOV      r0,r4
00002c  e8bd4010          POP      {r4,lr}
000030  2100              MOVS     r1,#0
000032  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L10.54|
;;;165        }
;;;166      }
;;;167    }
000036  bd10              POP      {r4,pc}
;;;168    
                          ENDP

                  |L10.56|
                          DCD      0x40005400
                  |L10.60|
                          DCD      0x40005800
                  |L10.64|
                          DCD      0x40005c00

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;466      */
;;;467    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;468    {
;;;469      /* Check the parameters */
;;;470      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;471      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;472      if (NewState != DISABLE)
;;;473      {
;;;474        /* Enable dual addressing mode */
;;;475        I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
;;;476      }
;;;477      else
;;;478      {
;;;479        /* Disable dual addressing mode */
;;;480        I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L11.12|
000006  f0410101          ORR      r1,r1,#1              ;475
00000a  e001              B        |L11.16|
                  |L11.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L11.16|
000010  8181              STRH     r1,[r0,#0xc]          ;475
;;;481      }
;;;482    }
000012  4770              BX       lr
;;;483    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;566      */
;;;567    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;568    {
;;;569      /* Check the parameters */
;;;570      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;571      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;572      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
;;;573      {
;;;574        /* I2C fast mode Tlow/Thigh=2 */
;;;575        I2Cx->CCR &= I2C_DutyCycle_2;
;;;576      }
;;;577      else
;;;578      {
;;;579        /* I2C fast mode Tlow/Thigh=16/9 */
;;;580        I2Cx->CCR |= I2C_DutyCycle_16_9;
000004  8b81              LDRH     r1,[r0,#0x1c]
000006  d002              BEQ      |L12.14|
000008  f4214180          BIC      r1,r1,#0x4000         ;575
00000c  e001              B        |L12.18|
                  |L12.14|
00000e  f4414180          ORR      r1,r1,#0x4000
                  |L12.18|
000012  8381              STRH     r1,[r0,#0x1c]         ;575
;;;581      }
;;;582    }
000014  4770              BX       lr
;;;583    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;490      */
;;;491    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;492    {
;;;493      /* Check the parameters */
;;;494      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;495      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;496      if (NewState != DISABLE)
;;;497      {
;;;498        /* Enable generall call */
;;;499        I2Cx->CR1 |= I2C_CR1_ENGC;
;;;500      }
;;;501      else
;;;502      {
;;;503        /* Disable generall call */
;;;504        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L13.12|
000006  f0410140          ORR      r1,r1,#0x40           ;499
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f0210140          BIC      r1,r1,#0x40
                  |L13.16|
000010  8001              STRH     r1,[r0,#0]            ;499
;;;505      }
;;;506    }
000012  4770              BX       lr
;;;507    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;337      */
;;;338    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;339    {
;;;340      /* Check the parameters */
;;;341      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;342      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;343      if (NewState != DISABLE)
;;;344      {
;;;345        /* Generate a START condition */
;;;346        I2Cx->CR1 |= I2C_CR1_START;
;;;347      }
;;;348      else
;;;349      {
;;;350        /* Disable the START condition generation */
;;;351        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L14.12|
000006  f4417180          ORR      r1,r1,#0x100          ;346
00000a  e001              B        |L14.16|
                  |L14.12|
00000c  f4217180          BIC      r1,r1,#0x100
                  |L14.16|
000010  8001              STRH     r1,[r0,#0]            ;346
;;;352      }
;;;353    }
000012  4770              BX       lr
;;;354    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;361      */
;;;362    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;363    {
;;;364      /* Check the parameters */
;;;365      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;366      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;367      if (NewState != DISABLE)
;;;368      {
;;;369        /* Generate a STOP condition */
;;;370        I2Cx->CR1 |= I2C_CR1_STOP;
;;;371      }
;;;372      else
;;;373      {
;;;374        /* Disable the STOP condition generation */
;;;375        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L15.12|
000006  f4417100          ORR      r1,r1,#0x200          ;370
00000a  e001              B        |L15.16|
                  |L15.12|
00000c  f4217100          BIC      r1,r1,#0x200
                  |L15.16|
000010  8001              STRH     r1,[r0,#0]            ;370
;;;376      }
;;;377    }
000012  4770              BX       lr
;;;378    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1199     */
;;;1200   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  2200              MOVS     r2,#0
;;;1201   {
;;;1202     FlagStatus bitstatus = RESET;
;;;1203     __IO uint32_t i2creg = 0, i2cxbase = 0;
;;;1204   
;;;1205     /* Check the parameters */
;;;1206     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1207     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1208   
;;;1209     /* Get the I2Cx peripheral base address */
;;;1210     i2cxbase = (uint32_t)I2Cx;
;;;1211     
;;;1212     /* Read flag register index */
;;;1213     i2creg = I2C_FLAG >> 28;
000002  0f0b              LSRS     r3,r1,#28
;;;1214     
;;;1215     /* Get bit[23:0] of the flag */
;;;1216     I2C_FLAG &= FLAG_MASK;
000004  f021417f          BIC      r1,r1,#0xff000000
;;;1217     
;;;1218     if(i2creg != 0)
000008  d001              BEQ      |L16.14|
;;;1219     {
;;;1220       /* Get the I2Cx SR1 register address */
;;;1221       i2cxbase += 0x14;
00000a  3014              ADDS     r0,r0,#0x14
00000c  e001              B        |L16.18|
                  |L16.14|
;;;1222     }
;;;1223     else
;;;1224     {
;;;1225       /* Flag in I2Cx SR2 Register */
;;;1226       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
00000e  0c09              LSRS     r1,r1,#16
;;;1227       /* Get the I2Cx SR2 register address */
;;;1228       i2cxbase += 0x18;
000010  3018              ADDS     r0,r0,#0x18
                  |L16.18|
;;;1229     }
;;;1230     
;;;1231     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
000012  6800              LDR      r0,[r0,#0]
000014  4208              TST      r0,r1
000016  d000              BEQ      |L16.26|
;;;1232     {
;;;1233       /* I2C_FLAG is set */
;;;1234       bitstatus = SET;
000018  2201              MOVS     r2,#1
                  |L16.26|
;;;1235     }
;;;1236     else
;;;1237     {
;;;1238       /* I2C_FLAG is reset */
;;;1239       bitstatus = RESET;
;;;1240     }
;;;1241     
;;;1242     /* Return the I2C_FLAG status */
;;;1243     return  bitstatus;
00001a  4610              MOV      r0,r2
;;;1244   }
00001c  4770              BX       lr
;;;1245   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1310     */
;;;1311   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b510              PUSH     {r4,lr}
;;;1312   {
;;;1313     ITStatus bitstatus = RESET;
;;;1314     uint32_t enablestatus = 0;
;;;1315   
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1318     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1319   
;;;1320     /* Check if the interrupt source is enabled or not */
;;;1321     enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
000002  8883              LDRH     r3,[r0,#4]
000004  2200              MOVS     r2,#0                 ;1313
000006  f00164e0          AND      r4,r1,#0x7000000
;;;1322     
;;;1323     /* Get bit[23:0] of the flag */
;;;1324     I2C_IT &= FLAG_MASK;
;;;1325   
;;;1326     /* Check the status of the specified I2C flag */
;;;1327     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
00000a  8a80              LDRH     r0,[r0,#0x14]
00000c  ea034314          AND      r3,r3,r4,LSR #16      ;1321
000010  f021417f          BIC      r1,r1,#0xff000000     ;1324
000014  4208              TST      r0,r1
000016  d001              BEQ      |L17.28|
000018  b103              CBZ      r3,|L17.28|
;;;1328     {
;;;1329       /* I2C_IT is set */
;;;1330       bitstatus = SET;
00001a  2201              MOVS     r2,#1
                  |L17.28|
;;;1331     }
;;;1332     else
;;;1333     {
;;;1334       /* I2C_IT is reset */
;;;1335       bitstatus = RESET;
;;;1336     }
;;;1337     /* Return the I2C_IT status */
;;;1338     return  bitstatus;
00001c  4610              MOV      r0,r2
;;;1339   }
00001e  bd10              POP      {r4,pc}
;;;1340   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;1144     */
;;;1145   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  8a81              LDRH     r1,[r0,#0x14]
;;;1146   {
;;;1147     uint32_t lastevent = 0;
;;;1148     uint32_t flag1 = 0, flag2 = 0;
;;;1149   
;;;1150     /* Check the parameters */
;;;1151     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1152   
;;;1153     /* Read the I2Cx status register */
;;;1154     flag1 = I2Cx->SR1;
;;;1155     flag2 = I2Cx->SR2;
000002  8b00              LDRH     r0,[r0,#0x18]
;;;1156     flag2 = flag2 << 16;
;;;1157   
;;;1158     /* Get the last event value from I2C status register */
;;;1159     lastevent = (flag1 | flag2) & FLAG_MASK;
000004  ea414100          ORR      r1,r1,r0,LSL #16
000008  f021407f          BIC      r0,r1,#0xff000000
;;;1160   
;;;1161     /* Return status */
;;;1162     return lastevent;
;;;1163   }
00000c  4770              BX       lr
;;;1164   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;815      */
;;;816    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  8b00              LDRH     r0,[r0,#0x18]
;;;817    {
;;;818      /* Check the parameters */
;;;819      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;820      /* Return the selected I2C PEC value */
;;;821      return ((I2Cx->SR2) >> 8);
000002  0a00              LSRS     r0,r0,#8
;;;822    }
000004  4770              BX       lr
;;;823    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;1037     */
;;;1038   void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1039   {
;;;1040     /* Check the parameters */
;;;1041     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1042     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1043     assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;1044     
;;;1045     if (NewState != DISABLE)
;;;1046     {
;;;1047       /* Enable the selected I2C interrupts */
;;;1048       I2Cx->CR2 |= I2C_IT;
;;;1049     }
;;;1050     else
;;;1051     {
;;;1052       /* Disable the selected I2C interrupts */
;;;1053       I2Cx->CR2 &= (uint16_t)~I2C_IT;
000002  8882              LDRH     r2,[r0,#4]
000004  d001              BEQ      |L20.10|
000006  430a              ORRS     r2,r2,r1              ;1048
000008  e000              B        |L20.12|
                  |L20.10|
00000a  438a              BICS     r2,r2,r1
                  |L20.12|
00000c  8082              STRH     r2,[r0,#4]            ;1048
;;;1054     }
;;;1055   }
00000e  4770              BX       lr
;;;1056   
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;180      */
;;;181    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  b57f              PUSH     {r0-r6,lr}
;;;182    {
000002  4604              MOV      r4,r0
;;;183      uint16_t tmpreg = 0, freqrange = 0;
;;;184      uint16_t result = 0x04;
;;;185      uint32_t pclk1 = 8000000;
;;;186      RCC_ClocksTypeDef  rcc_clocks;
;;;187      /* Check the parameters */
;;;188      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;189      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;190      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;191      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;192      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;193      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;194      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;195    
;;;196    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;197      /* Get the I2Cx CR2 value */
;;;198      tmpreg = I2Cx->CR2;
000004  8880              LDRH     r0,[r0,#4]
000006  460d              MOV      r5,r1                 ;182
;;;199      /* Clear frequency FREQ[5:0] bits */
;;;200      tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
000008  f020063f          BIC      r6,r0,#0x3f
;;;201      /* Get pclk1 frequency value */
;;;202      RCC_GetClocksFreq(&rcc_clocks);
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       RCC_GetClocksFreq
;;;203      pclk1 = rcc_clocks.PCLK1_Frequency;
;;;204      /* Set frequency bits depending on pclk1 value */
;;;205      freqrange = (uint16_t)(pclk1 / 1000000);
000012  4926              LDR      r1,|L21.172|
000014  9802              LDR      r0,[sp,#8]
000016  fbb0f1f1          UDIV     r1,r0,r1
00001a  b289              UXTH     r1,r1
;;;206      tmpreg |= freqrange;
00001c  430e              ORRS     r6,r6,r1
;;;207      /* Write to I2Cx CR2 */
;;;208      I2Cx->CR2 = tmpreg;
00001e  80a6              STRH     r6,[r4,#4]
;;;209    
;;;210    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;211      /* Disable the selected I2C peripheral to configure TRISE */
;;;212      I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000020  8822              LDRH     r2,[r4,#0]
000022  f0220201          BIC      r2,r2,#1
000026  8022              STRH     r2,[r4,#0]
;;;213      /* Reset tmpreg value */
;;;214      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;215      tmpreg = 0;
;;;216    
;;;217      /* Configure speed in standard mode */
;;;218      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
000028  4b21              LDR      r3,|L21.176|
00002a  682a              LDR      r2,[r5,#0]
00002c  429a              CMP      r2,r3
00002e  d81b              BHI      |L21.104|
;;;219      {
;;;220        /* Standard mode speed calculate */
;;;221        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000030  0052              LSLS     r2,r2,#1
000032  fbb0f0f2          UDIV     r0,r0,r2
000036  b280              UXTH     r0,r0
;;;222        /* Test if CCR value is under 0x4*/
;;;223        if (result < 0x04)
000038  2804              CMP      r0,#4
00003a  d200              BCS      |L21.62|
;;;224        {
;;;225          /* Set minimum allowed value */
;;;226          result = 0x04;  
00003c  2004              MOVS     r0,#4
                  |L21.62|
;;;227        }
;;;228        /* Set speed value for standard mode */
;;;229        tmpreg |= result;	  
;;;230        /* Set Maximum Rise Time for standard mode */
;;;231        I2Cx->TRISE = freqrange + 1; 
00003e  1c49              ADDS     r1,r1,#1
000040  8421              STRH     r1,[r4,#0x20]
;;;232      }
;;;233      /* Configure speed in fast mode */
;;;234      /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
;;;235         input clock) must be a multiple of 10 MHz */
;;;236      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;237      {
;;;238        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
;;;239        {
;;;240          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;241          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
;;;242        }
;;;243        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;244        {
;;;245          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;246          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
;;;247          /* Set DUTY bit */
;;;248          result |= I2C_DutyCycle_16_9;
;;;249        }
;;;250    
;;;251        /* Test if CCR value is under 0x1*/
;;;252        if ((result & I2C_CCR_CCR) == 0)
;;;253        {
;;;254          /* Set minimum allowed value */
;;;255          result |= (uint16_t)0x0001;  
;;;256        }
;;;257        /* Set speed value and set F/S bit for fast mode */
;;;258        tmpreg |= (uint16_t)(result | I2C_CCR_FS);
;;;259        /* Set Maximum Rise Time for fast mode */
;;;260        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
;;;261      }
;;;262    
;;;263      /* Write to I2Cx CCR */
;;;264      I2Cx->CCR = tmpreg;
000042  83a0              STRH     r0,[r4,#0x1c]
;;;265      /* Enable the selected I2C peripheral */
;;;266      I2Cx->CR1 |= I2C_CR1_PE;
000044  8820              LDRH     r0,[r4,#0]
000046  f0400001          ORR      r0,r0,#1
00004a  8020              STRH     r0,[r4,#0]
;;;267    
;;;268    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;269      /* Get the I2Cx CR1 value */
;;;270      tmpreg = I2Cx->CR1;
00004c  8821              LDRH     r1,[r4,#0]
;;;271      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;272      tmpreg &= CR1_CLEAR_MASK;
00004e  f64f30f5          MOV      r0,#0xfbf5
000052  4001              ANDS     r1,r1,r0
;;;273      /* Configure I2Cx: mode and acknowledgement */
;;;274      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;275      /* Set ACK bit according to I2C_Ack value */
;;;276      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
000054  88a8              LDRH     r0,[r5,#4]
000056  896a              LDRH     r2,[r5,#0xa]
000058  4310              ORRS     r0,r0,r2
00005a  4308              ORRS     r0,r0,r1
;;;277      /* Write to I2Cx CR1 */
;;;278      I2Cx->CR1 = tmpreg;
00005c  8020              STRH     r0,[r4,#0]
;;;279    
;;;280    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;281      /* Set I2Cx Own Address1 and acknowledged address */
;;;282      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
00005e  89a8              LDRH     r0,[r5,#0xc]
000060  8929              LDRH     r1,[r5,#8]
000062  4308              ORRS     r0,r0,r1
000064  8120              STRH     r0,[r4,#8]
;;;283    }
000066  bd7f              POP      {r0-r6,pc}
                  |L21.104|
000068  88eb              LDRH     r3,[r5,#6]            ;238
00006a  f5a3463f          SUB      r6,r3,#0xbf00         ;238
00006e  3eff              SUBS     r6,r6,#0xff           ;238
000070  d105              BNE      |L21.126|
000072  eb020242          ADD      r2,r2,r2,LSL #1       ;241
000076  fbb0f0f2          UDIV     r0,r0,r2              ;241
00007a  b280              UXTH     r0,r0                 ;241
00007c  e008              B        |L21.144|
                  |L21.126|
00007e  eb0203c2          ADD      r3,r2,r2,LSL #3       ;246
000082  eb031202          ADD      r2,r3,r2,LSL #4       ;246
000086  fbb0f0f2          UDIV     r0,r0,r2              ;246
00008a  b280              UXTH     r0,r0                 ;246
00008c  f4404080          ORR      r0,r0,#0x4000         ;248
                  |L21.144|
000090  0502              LSLS     r2,r0,#20             ;252
000092  d101              BNE      |L21.152|
000094  f0400001          ORR      r0,r0,#1              ;255
                  |L21.152|
000098  f44f7296          MOV      r2,#0x12c             ;260
00009c  4351              MULS     r1,r2,r1              ;260
00009e  f44f727a          MOV      r2,#0x3e8             ;260
0000a2  fbb1f1f2          UDIV     r1,r1,r2              ;260
0000a6  f4404000          ORR      r0,r0,#0x8000         ;258
0000aa  e7c8              B        |L21.62|
;;;284    
                          ENDP

                  |L21.172|
                          DCD      0x000f4240
                  |L21.176|
                          DCD      0x000186a0

                          AREA ||i.I2C_NACKPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_NACKPositionConfig PROC
;;;604      */
;;;605    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;606    {
;;;607      /* Check the parameters */
;;;608      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;609      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
;;;610      
;;;611      /* Check the input parameter */
;;;612      if (I2C_NACKPosition == I2C_NACKPosition_Next)
;;;613      {
;;;614        /* Next byte in shift register is the last received byte */
;;;615        I2Cx->CR1 |= I2C_NACKPosition_Next;
;;;616      }
;;;617      else
;;;618      {
;;;619        /* Current byte in shift register is the last received byte */
;;;620        I2Cx->CR1 &= I2C_NACKPosition_Current;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L22.16|
000008  f4216100          BIC      r1,r1,#0x800
                  |L22.12|
00000c  8001              STRH     r1,[r0,#0]            ;615
;;;621      }
;;;622    }
00000e  4770              BX       lr
                  |L22.16|
000010  f4416100          ORR      r1,r1,#0x800          ;615
000014  e7fa              B        |L22.12|
;;;623    
                          ENDP


                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;439      */
;;;440    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  8982              LDRH     r2,[r0,#0xc]
;;;441    {
;;;442      uint16_t tmpreg = 0;
;;;443    
;;;444      /* Check the parameters */
;;;445      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;446    
;;;447      /* Get the old register value */
;;;448      tmpreg = I2Cx->OAR2;
;;;449    
;;;450      /* Reset I2Cx Own address2 bit [7:1] */
;;;451      tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
;;;452    
;;;453      /* Set I2Cx Own address2 */
;;;454      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
000002  f00101fe          AND      r1,r1,#0xfe
000006  f02202fe          BIC      r2,r2,#0xfe           ;451
00000a  4311              ORRS     r1,r1,r2
;;;455    
;;;456      /* Store the new register value */
;;;457      I2Cx->OAR2 = tmpreg;
00000c  8181              STRH     r1,[r0,#0xc]
;;;458    }
00000e  4770              BX       lr
;;;459    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;769      */
;;;770    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;771    {
;;;772      /* Check the parameters */
;;;773      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;774      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;775      if (I2C_PECPosition == I2C_PECPosition_Next)
;;;776      {
;;;777        /* Next byte in shift register is PEC */
;;;778        I2Cx->CR1 |= I2C_PECPosition_Next;
;;;779      }
;;;780      else
;;;781      {
;;;782        /* Current byte in shift register is PEC */
;;;783        I2Cx->CR1 &= I2C_PECPosition_Current;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L24.16|
000008  f4216100          BIC      r1,r1,#0x800
                  |L24.12|
00000c  8001              STRH     r1,[r0,#0]            ;778
;;;784      }
;;;785    }
00000e  4770              BX       lr
                  |L24.16|
000010  f4416100          ORR      r1,r1,#0x800          ;778
000014  e7fa              B        |L24.12|
;;;786    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;1010     */
;;;1011   uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  5a40              LDRH     r0,[r0,r1]
;;;1012   {
;;;1013     __IO uint32_t tmp = 0;
;;;1014   
;;;1015     /* Check the parameters */
;;;1016     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1017     assert_param(IS_I2C_REGISTER(I2C_Register));
;;;1018   
;;;1019     tmp = (uint32_t) I2Cx;
;;;1020     tmp += I2C_Register;
;;;1021   
;;;1022     /* Return the selected register value */
;;;1023     return (*(__IO uint16_t *) tmp);
;;;1024   }
000002  4770              BX       lr
;;;1025   
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;707      */
;;;708    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  8a00              LDRH     r0,[r0,#0x10]
;;;709    {
;;;710      /* Check the parameters */
;;;711      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;712      /* Return the data in the DR register */
;;;713      return (uint8_t)I2Cx->DR;
000002  b2c0              UXTB     r0,r0
;;;714    }
000004  4770              BX       lr
;;;715    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;632      */
;;;633    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;634    {
;;;635      /* Check the parameters */
;;;636      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;637      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;638      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
;;;639      {
;;;640        /* Drive the SMBusAlert pin Low */
;;;641        I2Cx->CR1 |= I2C_SMBusAlert_Low;
;;;642      }
;;;643      else
;;;644      {
;;;645        /* Drive the SMBusAlert pin High  */
;;;646        I2Cx->CR1 &= I2C_SMBusAlert_High;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L27.16|
000008  f4215100          BIC      r1,r1,#0x2000
                  |L27.12|
00000c  8001              STRH     r1,[r0,#0]            ;641
;;;647      }
;;;648    }
00000e  4770              BX       lr
                  |L27.16|
000010  f4415100          ORR      r1,r1,#0x2000         ;641
000014  e7fa              B        |L27.12|
;;;649    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;389      */
;;;390    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b112              CBZ      r2,|L28.8|
;;;391    {
;;;392      /* Check the parameters */
;;;393      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;394      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;395      /* Test on the direction to set/reset the read/write bit */
;;;396      if (I2C_Direction != I2C_Direction_Transmitter)
;;;397      {
;;;398        /* Set the address bit0 for read */
;;;399        Address |= I2C_OAR1_ADD0;
000002  f0410101          ORR      r1,r1,#1
000006  e001              B        |L28.12|
                  |L28.8|
;;;400      }
;;;401      else
;;;402      {
;;;403        /* Reset the address bit0 for write */
;;;404        Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
000008  f00101fe          AND      r1,r1,#0xfe
                  |L28.12|
;;;405      }
;;;406      /* Send the address */
;;;407      I2Cx->DR = Address;
00000c  8201              STRH     r1,[r0,#0x10]
;;;408    }
00000e  4770              BX       lr
;;;409    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;694      */
;;;695    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;696    {
;;;697      /* Check the parameters */
;;;698      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;699      /* Write in the DR register the data to be sent */
;;;700      I2Cx->DR = Data;
;;;701    }
000002  4770              BX       lr
;;;702    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;516      */
;;;517    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;518    {
;;;519      /* Check the parameters */
;;;520      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;521      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;522      if (NewState != DISABLE)
;;;523      {
;;;524        /* Peripheral under reset */
;;;525        I2Cx->CR1 |= I2C_CR1_SWRST;
;;;526      }
;;;527      else
;;;528      {
;;;529        /* Peripheral not under reset */
;;;530        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L30.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;525
00000a  e001              B        |L30.16|
                  |L30.12|
00000c  f3c1010e          UBFX     r1,r1,#0,#15
                  |L30.16|
000010  8001              STRH     r1,[r0,#0]            ;525
;;;531      }
;;;532    }
000012  4770              BX       lr
;;;533    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;540      */
;;;541    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;542    {
;;;543      /* Check the parameters */
;;;544      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;545      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;546      if (NewState == DISABLE)
;;;547      {
;;;548        /* Enable the selected I2C Clock stretching */
;;;549        I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
;;;550      }
;;;551      else
;;;552      {
;;;553        /* Disable the selected I2C Clock stretching */
;;;554        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
000002  8801              LDRH     r1,[r0,#0]
000004  d003              BEQ      |L31.14|
000006  f0210180          BIC      r1,r1,#0x80
                  |L31.10|
00000a  8001              STRH     r1,[r0,#0]            ;549
;;;555      }
;;;556    }
00000c  4770              BX       lr
                  |L31.14|
00000e  f0410180          ORR      r1,r1,#0x80           ;549
000012  e7fa              B        |L31.10|
;;;557    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;289      */
;;;290    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;291    {
;;;292    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;293      /* initialize the I2C_ClockSpeed member */
;;;294      I2C_InitStruct->I2C_ClockSpeed = 5000;
;;;295      /* Initialize the I2C_Mode member */
;;;296      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;297      /* Initialize the I2C_DutyCycle member */
;;;298      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b72ff          MOV      r2,#0xbfff
00000e  80c2              STRH     r2,[r0,#6]
;;;299      /* Initialize the I2C_OwnAddress1 member */
;;;300      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  8101              STRH     r1,[r0,#8]
;;;301      /* Initialize the I2C_Ack member */
;;;302      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000012  8141              STRH     r1,[r0,#0xa]
;;;303      /* Initialize the I2C_AcknowledgedAddress member */
;;;304      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000014  f44f4180          MOV      r1,#0x4000
000018  8181              STRH     r1,[r0,#0xc]
;;;305    }
00001a  4770              BX       lr
;;;306    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;738      */
;;;739    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;740    {
;;;741      /* Check the parameters */
;;;742      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;743      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;744      if (NewState != DISABLE)
;;;745      {
;;;746        /* Enable the selected I2C PEC transmission */
;;;747        I2Cx->CR1 |= I2C_CR1_PEC;
;;;748      }
;;;749      else
;;;750      {
;;;751        /* Disable the selected I2C PEC transmission */
;;;752        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L33.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;747
00000a  e001              B        |L33.16|
                  |L33.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L33.16|
000010  8001              STRH     r1,[r0,#0]            ;747
;;;753      }
;;;754    }
000012  4770              BX       lr
;;;755    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_i2c.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REV16|
#line 114 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_i2c_c_7174d409____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REVSH|
#line 128
|__asm___15_stm32f4xx_i2c_c_7174d409____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
