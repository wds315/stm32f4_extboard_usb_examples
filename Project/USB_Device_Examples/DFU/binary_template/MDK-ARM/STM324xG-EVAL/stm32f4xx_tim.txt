; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\STM324xG-EVAL\stm32f4xx_tim.o --asm_dir=.\STM324xG-EVAL\ --list_dir=.\STM324xG-EVAL\ --depend=.\STM324xG-EVAL\stm32f4xx_tim.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -I..\ -I..\inc -I..\..\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\..\..\Utilities\STM32_EVAL -I..\..\..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F4XX -DUSE_STM324xG_EVAL --omf_browse=.\STM324xG-EVAL\stm32f4xx_tim.crf ..\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=1

                  TI1_Config PROC
;;;3196     */
;;;3197   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b510              PUSH     {r4,lr}
;;;3198                          uint16_t TIM_ICFilter)
;;;3199   {
;;;3200     uint16_t tmpccmr1 = 0, tmpccer = 0;
;;;3201   
;;;3202     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3203     TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f0240401          BIC      r4,r4,#1
000008  8404              STRH     r4,[r0,#0x20]
;;;3204     tmpccmr1 = TIMx->CCMR1;
00000a  f8b0c018          LDRH     r12,[r0,#0x18]
;;;3205     tmpccer = TIMx->CCER;
00000e  8c04              LDRH     r4,[r0,#0x20]
;;;3206   
;;;3207     /* Select the Input and set the filter */
;;;3208     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
;;;3209     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
000010  ea421303          ORR      r3,r2,r3,LSL #4
000014  f02c0cf3          BIC      r12,r12,#0xf3         ;3208
;;;3210   
;;;3211     /* Select the Polarity and set the CC1E Bit */
;;;3212     tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000018  f024020a          BIC      r2,r4,#0xa
00001c  ea43030c          ORR      r3,r3,r12             ;3209
;;;3213     tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
000020  430a              ORRS     r2,r2,r1
000022  f0420101          ORR      r1,r2,#1
;;;3214   
;;;3215     /* Write to TIMx CCMR1 and CCER registers */
;;;3216     TIMx->CCMR1 = tmpccmr1;
000026  8303              STRH     r3,[r0,#0x18]
;;;3217     TIMx->CCER = tmpccer;
000028  8401              STRH     r1,[r0,#0x20]
;;;3218   }
00002a  bd10              POP      {r4,pc}
;;;3219   
                          ENDP


                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=1

                  TI2_Config PROC
;;;3237     */
;;;3238   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;3239                          uint16_t TIM_ICFilter)
;;;3240   {
;;;3241     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
;;;3242   
;;;3243     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3244     TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f0240410          BIC      r4,r4,#0x10
000008  8404              STRH     r4,[r0,#0x20]
;;;3245     tmpccmr1 = TIMx->CCMR1;
00000a  f8b0c018          LDRH     r12,[r0,#0x18]
;;;3246     tmpccer = TIMx->CCER;
00000e  8c05              LDRH     r5,[r0,#0x20]
000010  010c              LSLS     r4,r1,#4
;;;3247     tmp = (uint16_t)(TIM_ICPolarity << 4);
;;;3248   
;;;3249     /* Select the Input and set the filter */
;;;3250     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
000012  f42c4c73          BIC      r12,r12,#0xf300
;;;3251     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
000016  ea4c3103          ORR      r1,r12,r3,LSL #12
;;;3252     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
00001a  ea412202          ORR      r2,r1,r2,LSL #8
;;;3253   
;;;3254     /* Select the Polarity and set the CC2E Bit */
;;;3255     tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
00001e  f02501a0          BIC      r1,r5,#0xa0
;;;3256     tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
000022  4321              ORRS     r1,r1,r4
000024  f0410110          ORR      r1,r1,#0x10
;;;3257   
;;;3258     /* Write to TIMx CCMR1 and CCER registers */
;;;3259     TIMx->CCMR1 = tmpccmr1 ;
000028  8302              STRH     r2,[r0,#0x18]
;;;3260     TIMx->CCER = tmpccer;
00002a  8401              STRH     r1,[r0,#0x20]
;;;3261   }
00002c  bd30              POP      {r4,r5,pc}
;;;3262   
                          ENDP


                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;521      */
;;;522    void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;523    {
;;;524      /* Check the parameters */
;;;525      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;526      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;527    
;;;528      if (NewState != DISABLE)
;;;529      {
;;;530        /* Set the ARR Preload Bit */
;;;531        TIMx->CR1 |= TIM_CR1_ARPE;
;;;532      }
;;;533      else
;;;534      {
;;;535        /* Reset the ARR Preload Bit */
;;;536        TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  f0410180          ORR      r1,r1,#0x80           ;531
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  f0210180          BIC      r1,r1,#0x80
                  |L3.16|
000010  8001              STRH     r1,[r0,#0]            ;531
;;;537      }
;;;538    }
000012  4770              BX       lr
;;;539    
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;2216     */
;;;2217   void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  b510              PUSH     {r4,lr}
;;;2218   {
;;;2219     /* Check the parameters */
;;;2220     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2221     assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;2222     assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;2223     assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;2224     assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;2225     assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;2226     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;2227   
;;;2228     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;2229        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;2230     TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  880a              LDRH     r2,[r1,#0]
000004  884b              LDRH     r3,[r1,#2]
000006  88cc              LDRH     r4,[r1,#6]
000008  431a              ORRS     r2,r2,r3
00000a  888b              LDRH     r3,[r1,#4]
00000c  4323              ORRS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  890b              LDRH     r3,[r1,#8]
000012  431a              ORRS     r2,r2,r3
000014  894b              LDRH     r3,[r1,#0xa]
000016  8989              LDRH     r1,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  430a              ORRS     r2,r2,r1
00001c  f8a02044          STRH     r2,[r0,#0x44]
;;;2231                TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;2232                TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;2233                TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;2234   }
000020  bd10              POP      {r4,pc}
;;;2235   
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;2241     */
;;;2242   void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;2243   {
;;;2244     /* Set the default configuration */
;;;2245     TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;2246     TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;2247     TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;2248     TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;2249     TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;2250     TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;2251     TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;2252   }
000010  4770              BX       lr
;;;2253   
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;2310     */
;;;2311   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2312   { 
;;;2313     /* Check the parameters */
;;;2314     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2315     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2316     if (NewState != DISABLE)
;;;2317     {
;;;2318       /* Set the CCPC Bit */
;;;2319       TIMx->CR2 |= TIM_CR2_CCPC;
;;;2320     }
;;;2321     else
;;;2322     {
;;;2323       /* Reset the CCPC Bit */
;;;2324       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L6.12|
000006  f0410101          ORR      r1,r1,#1              ;2319
00000a  e001              B        |L6.16|
                  |L6.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L6.16|
000010  8081              STRH     r1,[r0,#4]            ;2319
;;;2325     }
;;;2326   }
000012  4770              BX       lr
;;;2327   /**
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1783     */
;;;1784   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b510              PUSH     {r4,lr}
;;;1785   {
;;;1786     uint16_t tmp = 0;
;;;1787   
;;;1788     /* Check the parameters */
;;;1789     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;1790     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1791     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1792   
;;;1793     tmp = CCER_CCE_SET << TIM_Channel;
000002  2301              MOVS     r3,#1
;;;1794   
;;;1795     /* Reset the CCxE Bit */
;;;1796     TIMx->CCER &= (uint16_t)~ tmp;
000004  8c04              LDRH     r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;1793
000008  439c              BICS     r4,r4,r3
00000a  8404              STRH     r4,[r0,#0x20]
;;;1797   
;;;1798     /* Set or reset the CCxE Bit */ 
;;;1799     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  8403              STRH     r3,[r0,#0x20]
;;;1800   }
000014  bd10              POP      {r4,pc}
;;;1801   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;1813     */
;;;1814   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  b510              PUSH     {r4,lr}
;;;1815   {
;;;1816     uint16_t tmp = 0;
;;;1817   
;;;1818     /* Check the parameters */
;;;1819     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1820     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;1821     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;1822   
;;;1823     tmp = CCER_CCNE_SET << TIM_Channel;
000002  2304              MOVS     r3,#4
;;;1824   
;;;1825     /* Reset the CCxNE Bit */
;;;1826     TIMx->CCER &= (uint16_t) ~tmp;
000004  8c04              LDRH     r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;1823
000008  439c              BICS     r4,r4,r3
00000a  8404              STRH     r4,[r0,#0x20]
;;;1827   
;;;1828     /* Set or reset the CCxNE Bit */ 
;;;1829     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  8403              STRH     r3,[r0,#0x20]
;;;1830   }
000014  bd10              POP      {r4,pc}
;;;1831   /**
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2480     */
;;;2481   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43c9              MVNS     r1,r1
;;;2482   {  
;;;2483     /* Check the parameters */
;;;2484     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2485      
;;;2486     /* Clear the flags */
;;;2487     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8201              STRH     r1,[r0,#0x10]
;;;2488   }
000004  4770              BX       lr
;;;2489   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2549     */
;;;2550   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43c9              MVNS     r1,r1
;;;2551   {
;;;2552     /* Check the parameters */
;;;2553     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2554   
;;;2555     /* Clear the IT pending Bit */
;;;2556     TIMx->SR = (uint16_t)~TIM_IT;
000002  8201              STRH     r1,[r0,#0x10]
;;;2557   }
000004  4770              BX       lr
;;;2558   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1473     */
;;;1474   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1475   {
;;;1476     uint16_t tmpccmr1 = 0;
;;;1477   
;;;1478     /* Check the parameters */
;;;1479     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1480     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1481   
;;;1482     tmpccmr1 = TIMx->CCMR1;
;;;1483   
;;;1484     /* Reset the OC1CE Bit */
;;;1485     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
000002  f0220280          BIC      r2,r2,#0x80
;;;1486   
;;;1487     /* Enable or Disable the Output Compare Clear Bit */
;;;1488     tmpccmr1 |= TIM_OCClear;
000006  430a              ORRS     r2,r2,r1
;;;1489   
;;;1490     /* Write to TIMx CCMR1 register */
;;;1491     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1492   }
00000a  4770              BX       lr
;;;1493   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1503     */
;;;1504   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1505   {
;;;1506     uint16_t tmpccmr1 = 0;
;;;1507   
;;;1508     /* Check the parameters */
;;;1509     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1510     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1511   
;;;1512     tmpccmr1 = TIMx->CCMR1;
;;;1513   
;;;1514     /* Reset the OC2CE Bit */
;;;1515     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
000002  f3c2020e          UBFX     r2,r2,#0,#15
;;;1516   
;;;1517     /* Enable or Disable the Output Compare Clear Bit */
;;;1518     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1519   
;;;1520     /* Write to TIMx CCMR1 register */
;;;1521     TIMx->CCMR1 = tmpccmr1;
00000a  8301              STRH     r1,[r0,#0x18]
;;;1522   }
00000c  4770              BX       lr
;;;1523   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1532     */
;;;1533   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1534   {
;;;1535     uint16_t tmpccmr2 = 0;
;;;1536   
;;;1537     /* Check the parameters */
;;;1538     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1539     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1540   
;;;1541     tmpccmr2 = TIMx->CCMR2;
;;;1542   
;;;1543     /* Reset the OC3CE Bit */
;;;1544     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
000002  f0220280          BIC      r2,r2,#0x80
;;;1545   
;;;1546     /* Enable or Disable the Output Compare Clear Bit */
;;;1547     tmpccmr2 |= TIM_OCClear;
000006  430a              ORRS     r2,r2,r1
;;;1548   
;;;1549     /* Write to TIMx CCMR2 register */
;;;1550     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1551   }
00000a  4770              BX       lr
;;;1552   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1561     */
;;;1562   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1563   {
;;;1564     uint16_t tmpccmr2 = 0;
;;;1565   
;;;1566     /* Check the parameters */
;;;1567     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1568     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1569   
;;;1570     tmpccmr2 = TIMx->CCMR2;
;;;1571   
;;;1572     /* Reset the OC4CE Bit */
;;;1573     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
000002  f3c2020e          UBFX     r2,r2,#0,#15
;;;1574   
;;;1575     /* Enable or Disable the Output Compare Clear Bit */
;;;1576     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1577   
;;;1578     /* Write to TIMx CCMR2 register */
;;;1579     TIMx->CCMR2 = tmpccmr2;
00000a  8381              STRH     r1,[r0,#0x1c]
;;;1580   }
00000c  4770              BX       lr
;;;1581   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;591      */
;;;592    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;593    {
;;;594      /* Check the parameters */
;;;595      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;596      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;597      
;;;598      if (NewState != DISABLE)
;;;599      {
;;;600        /* Enable the TIM Counter */
;;;601        TIMx->CR1 |= TIM_CR1_CEN;
;;;602      }
;;;603      else
;;;604      {
;;;605        /* Disable the TIM Counter */
;;;606        TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L15.12|
000006  f0410101          ORR      r1,r1,#1              ;601
00000a  e001              B        |L15.16|
                  |L15.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L15.16|
000010  8001              STRH     r1,[r0,#0]            ;601
;;;607      }
;;;608    }
000012  4770              BX       lr
;;;609    /**
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;382      */
;;;383    void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  8802              LDRH     r2,[r0,#0]
;;;384    {
;;;385      uint16_t tmpcr1 = 0;
;;;386    
;;;387      /* Check the parameters */
;;;388      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;389      assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;390    
;;;391      tmpcr1 = TIMx->CR1;
;;;392    
;;;393      /* Reset the CMS and DIR Bits */
;;;394      tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
000002  f0220270          BIC      r2,r2,#0x70
;;;395    
;;;396      /* Set the Counter Mode */
;;;397      tmpcr1 |= TIM_CounterMode;
000006  430a              ORRS     r2,r2,r1
;;;398    
;;;399      /* Write to TIMx CR1 register */
;;;400      TIMx->CR1 = tmpcr1;
000008  8002              STRH     r2,[r0,#0]
;;;401    }
00000a  4770              BX       lr
;;;402    
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;2260     */
;;;2261   void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2262   {
;;;2263     /* Check the parameters */
;;;2264     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2265     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2266   
;;;2267     if (NewState != DISABLE)
;;;2268     {
;;;2269       /* Enable the TIM Main Output */
;;;2270       TIMx->BDTR |= TIM_BDTR_MOE;
;;;2271     }
;;;2272     else
;;;2273     {
;;;2274       /* Disable the TIM Main Output */
;;;2275       TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
000002  f8301f44          LDRH     r1,[r0,#0x44]!
000006  d002              BEQ      |L17.14|
000008  f4414100          ORR      r1,r1,#0x8000         ;2270
00000c  e001              B        |L17.18|
                  |L17.14|
00000e  f3c1010e          UBFX     r1,r1,#0,#15
                  |L17.18|
000012  8001              STRH     r1,[r0,#0]            ;2270
;;;2276     }  
;;;2277   }
000014  4770              BX       lr
;;;2278   
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;2613     */
;;;2614   void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;2615   { 
;;;2616     /* Check the parameters */
;;;2617     assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
;;;2618     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;2619     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2620     
;;;2621     if (NewState != DISABLE)
;;;2622     {
;;;2623       /* Enable the DMA sources */
;;;2624       TIMx->DIER |= TIM_DMASource; 
;;;2625     }
;;;2626     else
;;;2627     {
;;;2628       /* Disable the DMA sources */
;;;2629       TIMx->DIER &= (uint16_t)~TIM_DMASource;
000002  8982              LDRH     r2,[r0,#0xc]
000004  d001              BEQ      |L18.10|
000006  430a              ORRS     r2,r2,r1              ;2624
000008  e000              B        |L18.12|
                  |L18.10|
00000a  438a              BICS     r2,r2,r1
                  |L18.12|
00000c  8182              STRH     r2,[r0,#0xc]          ;2624
;;;2630     }
;;;2631   }
00000e  4770              BX       lr
;;;2632   
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;2586     */
;;;2587   void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  4311              ORRS     r1,r1,r2
;;;2588   {
;;;2589     /* Check the parameters */
;;;2590     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2591     assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
;;;2592     assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;2593   
;;;2594     /* Set the DMA Base and the DMA Burst Length */
;;;2595     TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000002  f8a01048          STRH     r1,[r0,#0x48]
;;;2596   }
000006  4770              BX       lr
;;;2597   
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;199      */
;;;200    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  4946              LDR      r1,|L20.284|
;;;201    {
000002  b510              PUSH     {r4,lr}
;;;202      /* Check the parameters */
;;;203      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;204     
;;;205      if (TIMx == TIM1)
000004  4288              CMP      r0,r1
000006  d106              BNE      |L20.22|
;;;206      {
;;;207        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;208        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000010  2100              MOVS     r1,#0
000012  2001              MOVS     r0,#1
000014  e05b              B        |L20.206|
                  |L20.22|
;;;209      } 
;;;210      else if (TIMx == TIM2) 
000016  f1b04f80          CMP      r0,#0x40000000
00001a  d009              BEQ      |L20.48|
;;;211      {     
;;;212        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;213        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
;;;214      }  
;;;215      else if (TIMx == TIM3)
00001c  4940              LDR      r1,|L20.288|
00001e  4288              CMP      r0,r1
000020  d10d              BNE      |L20.62|
;;;216      { 
;;;217        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
000022  2101              MOVS     r1,#1
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;218        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  2002              MOVS     r0,#2
00002e  e070              B        |L20.274|
                  |L20.48|
000030  2101              MOVS     r1,#1                 ;212
000032  4608              MOV      r0,r1                 ;212
000034  f7fffffe          BL       RCC_APB1PeriphResetCmd
000038  2100              MOVS     r1,#0                 ;213
00003a  2001              MOVS     r0,#1                 ;213
00003c  e069              B        |L20.274|
                  |L20.62|
;;;219      }  
;;;220      else if (TIMx == TIM4)
00003e  4939              LDR      r1,|L20.292|
000040  4288              CMP      r0,r1
000042  d106              BNE      |L20.82|
;;;221      { 
;;;222        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000044  2101              MOVS     r1,#1
000046  2004              MOVS     r0,#4
000048  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;223        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00004c  2100              MOVS     r1,#0
00004e  2004              MOVS     r0,#4
000050  e05f              B        |L20.274|
                  |L20.82|
;;;224      }  
;;;225      else if (TIMx == TIM5)
000052  4935              LDR      r1,|L20.296|
000054  4288              CMP      r0,r1
000056  d106              BNE      |L20.102|
;;;226      {      
;;;227        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000058  2101              MOVS     r1,#1
00005a  2008              MOVS     r0,#8
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;228        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
000060  2100              MOVS     r1,#0
000062  2008              MOVS     r0,#8
000064  e055              B        |L20.274|
                  |L20.102|
;;;229      }  
;;;230      else if (TIMx == TIM6)  
000066  4931              LDR      r1,|L20.300|
000068  4288              CMP      r0,r1
00006a  d106              BNE      |L20.122|
;;;231      {    
;;;232        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
00006c  2101              MOVS     r1,#1
00006e  2010              MOVS     r0,#0x10
000070  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;233        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
000074  2100              MOVS     r1,#0
000076  2010              MOVS     r0,#0x10
000078  e04b              B        |L20.274|
                  |L20.122|
;;;234      }  
;;;235      else if (TIMx == TIM7)
00007a  492d              LDR      r1,|L20.304|
00007c  4288              CMP      r0,r1
00007e  d106              BNE      |L20.142|
;;;236      {      
;;;237        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
000080  2101              MOVS     r1,#1
000082  2020              MOVS     r0,#0x20
000084  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;238        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
000088  2100              MOVS     r1,#0
00008a  2020              MOVS     r0,#0x20
00008c  e041              B        |L20.274|
                  |L20.142|
;;;239      }  
;;;240      else if (TIMx == TIM8)
00008e  4929              LDR      r1,|L20.308|
000090  4288              CMP      r0,r1
000092  d106              BNE      |L20.162|
;;;241      {      
;;;242        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
000094  2101              MOVS     r1,#1
000096  2002              MOVS     r0,#2
000098  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;243        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
00009c  2100              MOVS     r1,#0
00009e  2002              MOVS     r0,#2
0000a0  e015              B        |L20.206|
                  |L20.162|
;;;244      }  
;;;245      else if (TIMx == TIM9)
0000a2  4925              LDR      r1,|L20.312|
0000a4  4288              CMP      r0,r1
0000a6  d102              BNE      |L20.174|
;;;246      {      
;;;247        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
0000a8  2101              MOVS     r1,#1
0000aa  040c              LSLS     r4,r1,#16
;;;248        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
0000ac  e00a              B        |L20.196|
                  |L20.174|
;;;249       }  
;;;250      else if (TIMx == TIM10)
0000ae  4923              LDR      r1,|L20.316|
0000b0  4288              CMP      r0,r1
0000b2  d102              BNE      |L20.186|
;;;251      {      
;;;252        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
0000b4  2101              MOVS     r1,#1
0000b6  044c              LSLS     r4,r1,#17
;;;253        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
0000b8  e004              B        |L20.196|
                  |L20.186|
;;;254      }  
;;;255      else if (TIMx == TIM11) 
0000ba  4921              LDR      r1,|L20.320|
0000bc  4288              CMP      r0,r1
0000be  d10a              BNE      |L20.214|
;;;256      {     
;;;257        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
0000c0  2101              MOVS     r1,#1
0000c2  048c              LSLS     r4,r1,#18
                  |L20.196|
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;258        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
0000ca  2100              MOVS     r1,#0
0000cc  4620              MOV      r0,r4
                  |L20.206|
0000ce  e8bd4010          POP      {r4,lr}
0000d2  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L20.214|
;;;259      }  
;;;260      else if (TIMx == TIM12)
0000d6  491b              LDR      r1,|L20.324|
0000d8  4288              CMP      r0,r1
0000da  d106              BNE      |L20.234|
;;;261      {      
;;;262        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
0000dc  2101              MOVS     r1,#1
0000de  2040              MOVS     r0,#0x40
0000e0  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;263        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
0000e4  2100              MOVS     r1,#0
0000e6  2040              MOVS     r0,#0x40
0000e8  e013              B        |L20.274|
                  |L20.234|
;;;264      }  
;;;265      else if (TIMx == TIM13) 
0000ea  4917              LDR      r1,|L20.328|
0000ec  4288              CMP      r0,r1
0000ee  d106              BNE      |L20.254|
;;;266      {       
;;;267        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
0000f0  2101              MOVS     r1,#1
0000f2  2080              MOVS     r0,#0x80
0000f4  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;268        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
0000f8  2100              MOVS     r1,#0
0000fa  2080              MOVS     r0,#0x80
0000fc  e009              B        |L20.274|
                  |L20.254|
;;;269      }  
;;;270      else
;;;271      { 
;;;272        if (TIMx == TIM14) 
0000fe  4913              LDR      r1,|L20.332|
000100  4288              CMP      r0,r1
000102  d10a              BNE      |L20.282|
;;;273        {     
;;;274          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
000104  1584              ASRS     r4,r0,#22
000106  2101              MOVS     r1,#1
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;275          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
00010e  2100              MOVS     r1,#0
000110  4620              MOV      r0,r4
                  |L20.274|
000112  e8bd4010          POP      {r4,lr}
000116  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L20.282|
;;;276        }   
;;;277      }
;;;278    }
00011a  bd10              POP      {r4,pc}
;;;279    
                          ENDP

                  |L20.284|
                          DCD      0x40010000
                  |L20.288|
                          DCD      0x40000400
                  |L20.292|
                          DCD      0x40000800
                  |L20.296|
                          DCD      0x40000c00
                  |L20.300|
                          DCD      0x40001000
                  |L20.304|
                          DCD      0x40001400
                  |L20.308|
                          DCD      0x40010400
                  |L20.312|
                          DCD      0x40014000
                  |L20.316|
                          DCD      0x40014400
                  |L20.320|
                          DCD      0x40014800
                  |L20.324|
                          DCD      0x40001800
                  |L20.328|
                          DCD      0x40001c00
                  |L20.332|
                          DCD      0x40002000

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;2769     */
;;;2770   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000000  b510              PUSH     {r4,lr}
;;;2771                               uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2772   {
000002  4604              MOV      r4,r0
;;;2773     uint16_t tmpsmcr = 0;
;;;2774   
;;;2775     /* Check the parameters */
;;;2776     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2777     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2778     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2779     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2780     /* Configure the ETR Clock source */
;;;2781     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000004  f7fffffe          BL       TIM_ETRConfig
;;;2782     
;;;2783     /* Get the TIMx SMCR register value */
;;;2784     tmpsmcr = TIMx->SMCR;
000008  8920              LDRH     r0,[r4,#8]
;;;2785   
;;;2786     /* Reset the SMS Bits */
;;;2787     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
;;;2788   
;;;2789     /* Select the External clock mode1 */
;;;2790     tmpsmcr |= TIM_SlaveMode_External1;
;;;2791   
;;;2792     /* Select the Trigger selection : ETRF */
;;;2793     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
;;;2794     tmpsmcr |= TIM_TS_ETRF;
00000a  f0400077          ORR      r0,r0,#0x77
;;;2795   
;;;2796     /* Write to TIMx SMCR */
;;;2797     TIMx->SMCR = tmpsmcr;
00000e  8120              STRH     r0,[r4,#8]
;;;2798   }
000010  bd10              POP      {r4,pc}
;;;2799   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;2816     */
;;;2817   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b510              PUSH     {r4,lr}
;;;2818                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2819   {
000002  4604              MOV      r4,r0
;;;2820     /* Check the parameters */
;;;2821     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2822     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2823     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2824     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2825   
;;;2826     /* Configure the ETR Clock source */
;;;2827     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000004  f7fffffe          BL       TIM_ETRConfig
;;;2828   
;;;2829     /* Enable the External clock mode2 */
;;;2830     TIMx->SMCR |= TIM_SMCR_ECE;
000008  8920              LDRH     r0,[r4,#8]
00000a  f4404080          ORR      r0,r0,#0x4000
00000e  8120              STRH     r0,[r4,#8]
;;;2831   }
000010  bd10              POP      {r4,pc}
;;;2832   /**
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;3004     */
;;;3005   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000000  f8b0c008          LDRH     r12,[r0,#8]
;;;3006                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;3007   {
;;;3008     uint16_t tmpsmcr = 0;
;;;3009   
;;;3010     /* Check the parameters */
;;;3011     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3012     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;3013     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;3014     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;3015   
;;;3016     tmpsmcr = TIMx->SMCR;
;;;3017   
;;;3018     /* Reset the ETR Bits */
;;;3019     tmpsmcr &= SMCR_ETR_MASK;
;;;3020   
;;;3021     /* Set the Prescaler, the Filter value and the Polarity */
;;;3022     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
000004  ea422303          ORR      r3,r2,r3,LSL #8
000008  f00c0cff          AND      r12,r12,#0xff         ;3019
00000c  430b              ORRS     r3,r3,r1
00000e  ea43030c          ORR      r3,r3,r12
;;;3023   
;;;3024     /* Write to TIMx SMCR */
;;;3025     TIMx->SMCR = tmpsmcr;
000012  8103              STRH     r3,[r0,#8]
;;;3026   }
000014  4770              BX       lr
;;;3027   /**
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;3062     */
;;;3063   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b570              PUSH     {r4-r6,lr}
;;;3064                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;3065   {
;;;3066     uint16_t tmpsmcr = 0;
;;;3067     uint16_t tmpccmr1 = 0;
;;;3068     uint16_t tmpccer = 0;
;;;3069       
;;;3070     /* Check the parameters */
;;;3071     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3072     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;3073     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;3074     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;3075   
;;;3076     /* Get the TIMx SMCR register value */
;;;3077     tmpsmcr = TIMx->SMCR;
000002  8905              LDRH     r5,[r0,#8]
;;;3078   
;;;3079     /* Get the TIMx CCMR1 register value */
;;;3080     tmpccmr1 = TIMx->CCMR1;
000004  8b04              LDRH     r4,[r0,#0x18]
;;;3081   
;;;3082     /* Get the TIMx CCER register value */
;;;3083     tmpccer = TIMx->CCER;
000006  8c06              LDRH     r6,[r0,#0x20]
;;;3084   
;;;3085     /* Set the encoder Mode */
;;;3086     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
000008  f0250507          BIC      r5,r5,#7
;;;3087     tmpsmcr |= TIM_EncoderMode;
00000c  430d              ORRS     r5,r5,r1
;;;3088   
;;;3089     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;3090     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
00000e  f64f41fc          MOV      r1,#0xfcfc
000012  400c              ANDS     r4,r4,r1
;;;3091     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000014  f2401101          MOV      r1,#0x101
000018  430c              ORRS     r4,r4,r1
;;;3092   
;;;3093     /* Set the TI1 and the TI2 Polarities */
;;;3094     tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
00001a  f0260622          BIC      r6,r6,#0x22
;;;3095     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
00001e  ea421103          ORR      r1,r2,r3,LSL #4
000022  4331              ORRS     r1,r1,r6
;;;3096   
;;;3097     /* Write to TIMx SMCR */
;;;3098     TIMx->SMCR = tmpsmcr;
000024  8105              STRH     r5,[r0,#8]
;;;3099   
;;;3100     /* Write to TIMx CCMR1 */
;;;3101     TIMx->CCMR1 = tmpccmr1;
000026  8304              STRH     r4,[r0,#0x18]
;;;3102   
;;;3103     /* Write to TIMx CCER */
;;;3104     TIMx->CCER = tmpccer;
000028  8401              STRH     r1,[r0,#0x20]
;;;3105   }
00002a  bd70              POP      {r4-r6,pc}
;;;3106   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1121     */
;;;1122   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1123   {
;;;1124     uint16_t tmpccmr1 = 0;
;;;1125   
;;;1126     /* Check the parameters */
;;;1127     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1128     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1129     tmpccmr1 = TIMx->CCMR1;
;;;1130   
;;;1131     /* Reset the OC1M Bits */
;;;1132     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
000002  f0220270          BIC      r2,r2,#0x70
;;;1133   
;;;1134     /* Configure The Forced output Mode */
;;;1135     tmpccmr1 |= TIM_ForcedAction;
000006  430a              ORRS     r2,r2,r1
;;;1136   
;;;1137     /* Write to TIMx CCMR1 register */
;;;1138     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1139   }
00000a  4770              BX       lr
;;;1140   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1150     */
;;;1151   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1152   {
;;;1153     uint16_t tmpccmr1 = 0;
;;;1154   
;;;1155     /* Check the parameters */
;;;1156     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1157     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1158     tmpccmr1 = TIMx->CCMR1;
;;;1159   
;;;1160     /* Reset the OC2M Bits */
;;;1161     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
000002  f42242e0          BIC      r2,r2,#0x7000
;;;1162   
;;;1163     /* Configure The Forced output Mode */
;;;1164     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1165   
;;;1166     /* Write to TIMx CCMR1 register */
;;;1167     TIMx->CCMR1 = tmpccmr1;
00000a  8301              STRH     r1,[r0,#0x18]
;;;1168   }
00000c  4770              BX       lr
;;;1169   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1178     */
;;;1179   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1180   {
;;;1181     uint16_t tmpccmr2 = 0;
;;;1182   
;;;1183     /* Check the parameters */
;;;1184     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1185     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1186   
;;;1187     tmpccmr2 = TIMx->CCMR2;
;;;1188   
;;;1189     /* Reset the OC1M Bits */
;;;1190     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
000002  f0220270          BIC      r2,r2,#0x70
;;;1191   
;;;1192     /* Configure The Forced output Mode */
;;;1193     tmpccmr2 |= TIM_ForcedAction;
000006  430a              ORRS     r2,r2,r1
;;;1194   
;;;1195     /* Write to TIMx CCMR2 register */
;;;1196     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1197   }
00000a  4770              BX       lr
;;;1198   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1207     */
;;;1208   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1209   {
;;;1210     uint16_t tmpccmr2 = 0;
;;;1211   
;;;1212     /* Check the parameters */
;;;1213     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1214     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1215     tmpccmr2 = TIMx->CCMR2;
;;;1216   
;;;1217     /* Reset the OC2M Bits */
;;;1218     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
000002  f42242e0          BIC      r2,r2,#0x7000
;;;1219   
;;;1220     /* Configure The Forced output Mode */
;;;1221     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1222   
;;;1223     /* Write to TIMx CCMR2 register */
;;;1224     TIMx->CCMR2 = tmpccmr2;
00000a  8381              STRH     r1,[r0,#0x1c]
;;;1225   }
00000c  4770              BX       lr
;;;1226   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;2405     */
;;;2406   void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;2407   { 
;;;2408     /* Check the parameters */
;;;2409     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2410     assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;2411    
;;;2412     /* Set the event sources */
;;;2413     TIMx->EGR = TIM_EventSource;
;;;2414   }
000002  4770              BX       lr
;;;2415   
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2027     */
;;;2028   uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  6b40              LDR      r0,[r0,#0x34]
;;;2029   {
;;;2030     /* Check the parameters */
;;;2031     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2032   
;;;2033     /* Get the Capture 1 Register value */
;;;2034     return TIMx->CCR1;
;;;2035   }
000002  4770              BX       lr
;;;2036   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2042     */
;;;2043   uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  6b80              LDR      r0,[r0,#0x38]
;;;2044   {
;;;2045     /* Check the parameters */
;;;2046     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2047   
;;;2048     /* Get the Capture 2 Register value */
;;;2049     return TIMx->CCR2;
;;;2050   }
000002  4770              BX       lr
;;;2051   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2056     */
;;;2057   uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;2058   {
;;;2059     /* Check the parameters */
;;;2060     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2061   
;;;2062     /* Get the Capture 3 Register value */
;;;2063     return TIMx->CCR3;
;;;2064   }
000002  4770              BX       lr
;;;2065   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2070     */
;;;2071   uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  6c00              LDR      r0,[r0,#0x40]
;;;2072   {
;;;2073     /* Check the parameters */
;;;2074     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2075   
;;;2076     /* Get the Capture 4 Register value */
;;;2077     return TIMx->CCR4;
;;;2078   }
000002  4770              BX       lr
;;;2079   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;437      */
;;;438    uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  6a40              LDR      r0,[r0,#0x24]
;;;439    {
;;;440      /* Check the parameters */
;;;441      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;442    
;;;443      /* Get the Counter Register value */
;;;444      return TIMx->CNT;
;;;445    }
000002  4770              BX       lr
;;;446    
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2438     */
;;;2439   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2440   { 
;;;2441     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2442     /* Check the parameters */
;;;2443     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2444     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2445   
;;;2446     
;;;2447     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a12              LDRH     r2,[r2,#0x10]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L35.12|
;;;2448     {
;;;2449       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L35.12|
;;;2450     }
;;;2451     else
;;;2452     {
;;;2453       bitstatus = RESET;
;;;2454     }
;;;2455     return bitstatus;
;;;2456   }
00000c  4770              BX       lr
;;;2457   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2508     */
;;;2509   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  8a03              LDRH     r3,[r0,#0x10]
;;;2510   {
;;;2511     ITStatus bitstatus = RESET;  
000002  2200              MOVS     r2,#0
;;;2512     uint16_t itstatus = 0x0, itenable = 0x0;
;;;2513     /* Check the parameters */
;;;2514     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2515     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2516      
;;;2517     itstatus = TIMx->SR & TIM_IT;
;;;2518     
;;;2519     itenable = TIMx->DIER & TIM_IT;
000004  8980              LDRH     r0,[r0,#0xc]
000006  420b              TST      r3,r1                 ;2517
000008  ea000001          AND      r0,r0,r1
;;;2520     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
00000c  d001              BEQ      |L36.18|
00000e  b100              CBZ      r0,|L36.18|
;;;2521     {
;;;2522       bitstatus = SET;
000010  2201              MOVS     r2,#1
                  |L36.18|
;;;2523     }
;;;2524     else
;;;2525     {
;;;2526       bitstatus = RESET;
;;;2527     }
;;;2528     return bitstatus;
000012  4610              MOV      r0,r2
;;;2529   }
000014  4770              BX       lr
;;;2530   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;451      */
;;;452    uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  8d00              LDRH     r0,[r0,#0x28]
;;;453    {
;;;454      /* Check the parameters */
;;;455      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;456    
;;;457      /* Get the Prescaler Register value */
;;;458      return TIMx->PSC;
;;;459    }
000002  4770              BX       lr
;;;460    
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;1895     */
;;;1896   void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1897   {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;1898     /* Check the parameters */
;;;1899     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1900     assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;1901     assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;1902     assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;1903     assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;1904     
;;;1905     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000006  8808              LDRH     r0,[r1,#0]
;;;1906     {
;;;1907       /* TI1 Configuration */
;;;1908       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000008  8849              LDRH     r1,[r1,#2]
00000a  88a2              LDRH     r2,[r4,#4]
00000c  8923              LDRH     r3,[r4,#8]
00000e  b1e8              CBZ      r0,|L38.76|
;;;1909                  TIM_ICInitStruct->TIM_ICSelection,
;;;1910                  TIM_ICInitStruct->TIM_ICFilter);
;;;1911       /* Set the Input Capture Prescaler value */
;;;1912       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1913     }
;;;1914     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000010  2804              CMP      r0,#4
000012  d024              BEQ      |L38.94|
;;;1915     {
;;;1916       /* TI2 Configuration */
;;;1917       assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1918       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;1919                  TIM_ICInitStruct->TIM_ICSelection,
;;;1920                  TIM_ICInitStruct->TIM_ICFilter);
;;;1921       /* Set the Input Capture Prescaler value */
;;;1922       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1923     }
;;;1924     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000014  2808              CMP      r0,#8
000016  8c28              LDRH     r0,[r5,#0x20]
000018  d02a              BEQ      |L38.112|
00001a  f4205080          BIC      r0,r0,#0x1000
00001e  8428              STRH     r0,[r5,#0x20]
000020  8bae              LDRH     r6,[r5,#0x1c]
000022  8c28              LDRH     r0,[r5,#0x20]
000024  f4264673          BIC      r6,r6,#0xf300
000028  ea462202          ORR      r2,r6,r2,LSL #8
00002c  f4204020          BIC      r0,r0,#0xa000
000030  ea423303          ORR      r3,r2,r3,LSL #12
000034  ea403001          ORR      r0,r0,r1,LSL #12
000038  f4405080          ORR      r0,r0,#0x1000
00003c  83ab              STRH     r3,[r5,#0x1c]
00003e  8428              STRH     r0,[r5,#0x20]
;;;1925     {
;;;1926       /* TI3 Configuration */
;;;1927       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1928       TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
;;;1929                  TIM_ICInitStruct->TIM_ICSelection,
;;;1930                  TIM_ICInitStruct->TIM_ICFilter);
;;;1931       /* Set the Input Capture Prescaler value */
;;;1932       TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1933     }
;;;1934     else
;;;1935     {
;;;1936       /* TI4 Configuration */
;;;1937       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1938       TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;1939                  TIM_ICInitStruct->TIM_ICSelection,
;;;1940                  TIM_ICInitStruct->TIM_ICFilter);
;;;1941       /* Set the Input Capture Prescaler value */
;;;1942       TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000040  88e1              LDRH     r1,[r4,#6]
000042  4628              MOV      r0,r5
000044  e8bd4070          POP      {r4-r6,lr}
000048  f7ffbffe          B.W      TIM_SetIC4Prescaler
                  |L38.76|
00004c  4628              MOV      r0,r5                 ;1908
00004e  f7fffffe          BL       TI1_Config
000052  88e1              LDRH     r1,[r4,#6]            ;1912
000054  4628              MOV      r0,r5                 ;1912
000056  e8bd4070          POP      {r4-r6,lr}            ;1912
00005a  f7ffbffe          B.W      TIM_SetIC1Prescaler
                  |L38.94|
00005e  4628              MOV      r0,r5                 ;1918
000060  f7fffffe          BL       TI2_Config
000064  88e1              LDRH     r1,[r4,#6]            ;1922
000066  4628              MOV      r0,r5                 ;1922
000068  e8bd4070          POP      {r4-r6,lr}            ;1922
00006c  f7ffbffe          B.W      TIM_SetIC2Prescaler
                  |L38.112|
000070  f4207080          BIC      r0,r0,#0x100          ;1922
000074  8428              STRH     r0,[r5,#0x20]         ;1922
000076  8bae              LDRH     r6,[r5,#0x1c]         ;1922
000078  8c28              LDRH     r0,[r5,#0x20]         ;1922
00007a  f02606f3          BIC      r6,r6,#0xf3           ;1922
00007e  ea421303          ORR      r3,r2,r3,LSL #4       ;1922
000082  f4206020          BIC      r0,r0,#0xa00          ;1922
000086  4333              ORRS     r3,r3,r6              ;1922
000088  ea402001          ORR      r0,r0,r1,LSL #8       ;1922
00008c  f4407080          ORR      r0,r0,#0x100          ;1922
000090  83ab              STRH     r3,[r5,#0x1c]         ;1922
000092  8428              STRH     r0,[r5,#0x20]         ;1922
000094  88e1              LDRH     r1,[r4,#6]            ;1932
000096  4628              MOV      r0,r5                 ;1932
000098  e8bd4070          POP      {r4-r6,lr}            ;1932
00009c  f7ffbffe          B.W      TIM_SetIC3Prescaler
;;;1943     }
;;;1944   }
;;;1945   
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;1951     */
;;;1952   void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;1953   {
;;;1954     /* Set the default configuration */
;;;1955     TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;1956     TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;1957     TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2201              MOVS     r2,#1
000008  8082              STRH     r2,[r0,#4]
;;;1958     TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;1959     TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000c  8101              STRH     r1,[r0,#8]
;;;1960   }
00000e  4770              BX       lr
;;;1961   
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;2367     */
;;;2368   void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;2369   {  
;;;2370     /* Check the parameters */
;;;2371     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2372     assert_param(IS_TIM_IT(TIM_IT));
;;;2373     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2374     
;;;2375     if (NewState != DISABLE)
;;;2376     {
;;;2377       /* Enable the Interrupt sources */
;;;2378       TIMx->DIER |= TIM_IT;
;;;2379     }
;;;2380     else
;;;2381     {
;;;2382       /* Disable the Interrupt sources */
;;;2383       TIMx->DIER &= (uint16_t)~TIM_IT;
000002  8982              LDRH     r2,[r0,#0xc]
000004  d001              BEQ      |L40.10|
000006  430a              ORRS     r2,r2,r1              ;2378
000008  e000              B        |L40.12|
                  |L40.10|
00000a  438a              BICS     r2,r2,r1
                  |L40.12|
00000c  8182              STRH     r2,[r0,#0xc]          ;2378
;;;2384     }
;;;2385   }
00000e  4770              BX       lr
;;;2386   
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;2699     */
;;;2700   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  b500              PUSH     {lr}
;;;2701   {
000002  4603              MOV      r3,r0
;;;2702     /* Check the parameters */
;;;2703     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2704     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2705   
;;;2706     /* Select the Internal Trigger */
;;;2707     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000004  f7fffffe          BL       TIM_SelectInputTrigger
;;;2708   
;;;2709     /* Select the External clock mode1 */
;;;2710     TIMx->SMCR |= TIM_SlaveMode_External1;
000008  8918              LDRH     r0,[r3,#8]
00000a  f0400007          ORR      r0,r0,#7
00000e  8118              STRH     r0,[r3,#8]
;;;2711   }
000010  bd00              POP      {pc}
;;;2712   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;2678     */
;;;2679   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;2680   {
;;;2681     /* Check the parameters */
;;;2682     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2683   
;;;2684     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;2685     TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
000002  f0210107          BIC      r1,r1,#7
000006  8101              STRH     r1,[r0,#8]
;;;2686   }
000008  4770              BX       lr
;;;2687   
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1352     */
;;;1353   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1354   {
;;;1355     uint16_t tmpccmr1 = 0;
;;;1356   
;;;1357     /* Check the parameters */
;;;1358     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1359     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1360   
;;;1361     /* Get the TIMx CCMR1 register value */
;;;1362     tmpccmr1 = TIMx->CCMR1;
;;;1363   
;;;1364     /* Reset the OC1FE Bit */
;;;1365     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
000002  f0220204          BIC      r2,r2,#4
;;;1366   
;;;1367     /* Enable or Disable the Output Compare Fast Bit */
;;;1368     tmpccmr1 |= TIM_OCFast;
000006  430a              ORRS     r2,r2,r1
;;;1369   
;;;1370     /* Write to TIMx CCMR1 */
;;;1371     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1372   }
00000a  4770              BX       lr
;;;1373   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;670      */
;;;671    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;672    {
;;;673      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;674       
;;;675      /* Check the parameters */
;;;676      assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;677      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;678      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;679      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;680    
;;;681      /* Disable the Channel 1: Reset the CC1E Bit */
;;;682      TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  8402              STRH     r2,[r0,#0x20]
;;;683      
;;;684      /* Get the TIMx CCER register value */
;;;685      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;686      /* Get the TIMx CR2 register value */
;;;687      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;688      
;;;689      /* Get the TIMx CCMR1 register value */
;;;690      tmpccmrx = TIMx->CCMR1;
00000e  8b04              LDRH     r4,[r0,#0x18]
;;;691        
;;;692      /* Reset the Output Compare Mode Bits */
;;;693      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
;;;694      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
;;;695      /* Select the Output Compare Mode */
;;;696      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
;;;697      
;;;698      /* Reset the Output Polarity level */
;;;699      tmpccer &= (uint16_t)~TIM_CCER_CC1P;
000010  f0220202          BIC      r2,r2,#2
000014  f0240573          BIC      r5,r4,#0x73           ;694
000018  880c              LDRH     r4,[r1,#0]            ;696
00001a  432c              ORRS     r4,r4,r5              ;696
;;;700      /* Set the Output Compare Polarity */
;;;701      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00001c  898d              LDRH     r5,[r1,#0xc]
00001e  4315              ORRS     r5,r5,r2
;;;702      
;;;703      /* Set the Output State */
;;;704      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000020  884a              LDRH     r2,[r1,#2]
000022  432a              ORRS     r2,r2,r5
;;;705        
;;;706      if((TIMx == TIM1) || (TIMx == TIM8))
000024  4d0c              LDR      r5,|L44.88|
000026  42a8              CMP      r0,r5
000028  d002              BEQ      |L44.48|
00002a  4d0c              LDR      r5,|L44.92|
00002c  42a8              CMP      r0,r5
00002e  d10d              BNE      |L44.76|
                  |L44.48|
;;;707      {
;;;708        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;709        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;710        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;711        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;712        
;;;713        /* Reset the Output N Polarity level */
;;;714        tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
000030  f0220508          BIC      r5,r2,#8
;;;715        /* Set the Output N Polarity */
;;;716        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000034  89ca              LDRH     r2,[r1,#0xe]
;;;717        /* Reset the Output N State */
;;;718        tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
;;;719        
;;;720        /* Set the Output N State */
;;;721        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
;;;722        /* Reset the Output Compare and Output Compare N IDLE State */
;;;723        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
;;;724        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
000036  f4237340          BIC      r3,r3,#0x300
00003a  432a              ORRS     r2,r2,r5              ;716
00003c  f0220504          BIC      r5,r2,#4              ;718
000040  888a              LDRH     r2,[r1,#4]            ;721
000042  432a              ORRS     r2,r2,r5              ;721
;;;725        /* Set the Output Idle state */
;;;726        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000044  8a0d              LDRH     r5,[r1,#0x10]
000046  431d              ORRS     r5,r5,r3
;;;727        /* Set the Output N Idle state */
;;;728        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000048  8a4b              LDRH     r3,[r1,#0x12]
00004a  432b              ORRS     r3,r3,r5
                  |L44.76|
;;;729      }
;;;730      /* Write to TIMx CR2 */
;;;731      TIMx->CR2 = tmpcr2;
00004c  8083              STRH     r3,[r0,#4]
;;;732      
;;;733      /* Write to TIMx CCMR1 */
;;;734      TIMx->CCMR1 = tmpccmrx;
00004e  8304              STRH     r4,[r0,#0x18]
;;;735      
;;;736      /* Set the Capture Compare Register value */
;;;737      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
000050  6889              LDR      r1,[r1,#8]
000052  6341              STR      r1,[r0,#0x34]
;;;738      
;;;739      /* Write to TIMx CCER */
;;;740      TIMx->CCER = tmpccer;
000054  8402              STRH     r2,[r0,#0x20]
;;;741    }
000056  bd30              POP      {r4,r5,pc}
;;;742    
                          ENDP

                  |L44.88|
                          DCD      0x40010000
                  |L44.92|
                          DCD      0x40010400

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;1617     */
;;;1618   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1619   {
;;;1620     uint16_t tmpccer = 0;
;;;1621     /* Check the parameters */
;;;1622     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1623     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1624      
;;;1625     tmpccer = TIMx->CCER;
;;;1626   
;;;1627     /* Set or Reset the CC1NP Bit */
;;;1628     tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
000002  f0220208          BIC      r2,r2,#8
;;;1629     tmpccer |= TIM_OCNPolarity;
000006  430a              ORRS     r2,r2,r1
;;;1630   
;;;1631     /* Write to TIMx CCER register */
;;;1632     TIMx->CCER = tmpccer;
000008  8402              STRH     r2,[r0,#0x20]
;;;1633   }
00000a  4770              BX       lr
;;;1634   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1590     */
;;;1591   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1592   {
;;;1593     uint16_t tmpccer = 0;
;;;1594   
;;;1595     /* Check the parameters */
;;;1596     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1597     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1598   
;;;1599     tmpccer = TIMx->CCER;
;;;1600   
;;;1601     /* Set or Reset the CC1P Bit */
;;;1602     tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
000002  f0220202          BIC      r2,r2,#2
;;;1603     tmpccer |= TIM_OCPolarity;
000006  430a              ORRS     r2,r2,r1
;;;1604   
;;;1605     /* Write to TIMx CCER register */
;;;1606     TIMx->CCER = tmpccer;
000008  8402              STRH     r2,[r0,#0x20]
;;;1607   }
00000a  4770              BX       lr
;;;1608   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1235     */
;;;1236   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1237   {
;;;1238     uint16_t tmpccmr1 = 0;
;;;1239   
;;;1240     /* Check the parameters */
;;;1241     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1242     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1243   
;;;1244     tmpccmr1 = TIMx->CCMR1;
;;;1245   
;;;1246     /* Reset the OC1PE Bit */
;;;1247     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
000002  f0220208          BIC      r2,r2,#8
;;;1248   
;;;1249     /* Enable or Disable the Output Compare Preload feature */
;;;1250     tmpccmr1 |= TIM_OCPreload;
000006  430a              ORRS     r2,r2,r1
;;;1251   
;;;1252     /* Write to TIMx CCMR1 register */
;;;1253     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1254   }
00000a  4770              BX       lr
;;;1255   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1383     */
;;;1384   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1385   {
;;;1386     uint16_t tmpccmr1 = 0;
;;;1387   
;;;1388     /* Check the parameters */
;;;1389     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1390     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1391   
;;;1392     /* Get the TIMx CCMR1 register value */
;;;1393     tmpccmr1 = TIMx->CCMR1;
;;;1394   
;;;1395     /* Reset the OC2FE Bit */
;;;1396     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
000002  f4226280          BIC      r2,r2,#0x400
;;;1397   
;;;1398     /* Enable or Disable the Output Compare Fast Bit */
;;;1399     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1400   
;;;1401     /* Write to TIMx CCMR1 */
;;;1402     TIMx->CCMR1 = tmpccmr1;
00000a  8301              STRH     r1,[r0,#0x18]
;;;1403   }
00000c  4770              BX       lr
;;;1404   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;751      */
;;;752    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;753    {
;;;754      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;755       
;;;756      /* Check the parameters */
;;;757      assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
;;;758      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;759      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;760      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;761    
;;;762      /* Disable the Channel 2: Reset the CC2E Bit */
;;;763      TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  8402              STRH     r2,[r0,#0x20]
;;;764      
;;;765      /* Get the TIMx CCER register value */  
;;;766      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;767      /* Get the TIMx CR2 register value */
;;;768      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;769      
;;;770      /* Get the TIMx CCMR1 register value */
;;;771      tmpccmrx = TIMx->CCMR1;
00000e  8b04              LDRH     r4,[r0,#0x18]
;;;772        
;;;773      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;774      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
;;;775      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
;;;776      
;;;777      /* Select the Output Compare Mode */
;;;778      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
;;;779      
;;;780      /* Reset the Output Polarity level */
;;;781      tmpccer &= (uint16_t)~TIM_CCER_CC2P;
000010  f0220220          BIC      r2,r2,#0x20
000014  f42445e6          BIC      r5,r4,#0x7300         ;775
000018  880c              LDRH     r4,[r1,#0]            ;778
00001a  0624              LSLS     r4,r4,#24             ;778
00001c  ea454414          ORR      r4,r5,r4,LSR #16      ;778
;;;782      /* Set the Output Compare Polarity */
;;;783      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000020  898d              LDRH     r5,[r1,#0xc]
000022  052d              LSLS     r5,r5,#20
000024  ea424515          ORR      r5,r2,r5,LSR #16
;;;784      
;;;785      /* Set the Output State */
;;;786      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
000028  884a              LDRH     r2,[r1,#2]
00002a  0512              LSLS     r2,r2,#20
00002c  ea454212          ORR      r2,r5,r2,LSR #16
;;;787        
;;;788      if((TIMx == TIM1) || (TIMx == TIM8))
000030  4d10              LDR      r5,|L49.116|
000032  42a8              CMP      r0,r5
000034  d002              BEQ      |L49.60|
000036  4d10              LDR      r5,|L49.120|
000038  42a8              CMP      r0,r5
00003a  d115              BNE      |L49.104|
                  |L49.60|
;;;789      {
;;;790        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;791        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;792        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;793        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;794        
;;;795        /* Reset the Output N Polarity level */
;;;796        tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
00003c  f0220580          BIC      r5,r2,#0x80
;;;797        /* Set the Output N Polarity */
;;;798        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
000040  89ca              LDRH     r2,[r1,#0xe]
;;;799        /* Reset the Output N State */
;;;800        tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
;;;801        
;;;802        /* Set the Output N State */
;;;803        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
;;;804        /* Reset the Output Compare and Output Compare N IDLE State */
;;;805        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
;;;806        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
000042  f4236340          BIC      r3,r3,#0xc00
000046  0512              LSLS     r2,r2,#20             ;798
000048  ea454212          ORR      r2,r5,r2,LSR #16      ;798
00004c  f0220540          BIC      r5,r2,#0x40           ;800
000050  888a              LDRH     r2,[r1,#4]            ;803
000052  0512              LSLS     r2,r2,#20             ;803
000054  ea454212          ORR      r2,r5,r2,LSR #16      ;803
;;;807        /* Set the Output Idle state */
;;;808        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
000058  8a0d              LDRH     r5,[r1,#0x10]
00005a  04ad              LSLS     r5,r5,#18
00005c  ea434515          ORR      r5,r3,r5,LSR #16
;;;809        /* Set the Output N Idle state */
;;;810        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
000060  8a4b              LDRH     r3,[r1,#0x12]
000062  049b              LSLS     r3,r3,#18
000064  ea454313          ORR      r3,r5,r3,LSR #16
                  |L49.104|
;;;811      }
;;;812      /* Write to TIMx CR2 */
;;;813      TIMx->CR2 = tmpcr2;
000068  8083              STRH     r3,[r0,#4]
;;;814      
;;;815      /* Write to TIMx CCMR1 */
;;;816      TIMx->CCMR1 = tmpccmrx;
00006a  8304              STRH     r4,[r0,#0x18]
;;;817      
;;;818      /* Set the Capture Compare Register value */
;;;819      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
00006c  6889              LDR      r1,[r1,#8]
00006e  6381              STR      r1,[r0,#0x38]
;;;820      
;;;821      /* Write to TIMx CCER */
;;;822      TIMx->CCER = tmpccer;
000070  8402              STRH     r2,[r0,#0x20]
;;;823    }
000072  bd30              POP      {r4,r5,pc}
;;;824    
                          ENDP

                  |L49.116|
                          DCD      0x40010000
                  |L49.120|
                          DCD      0x40010400

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;1671     */
;;;1672   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1673   {
;;;1674     uint16_t tmpccer = 0;
;;;1675   
;;;1676     /* Check the parameters */
;;;1677     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1678     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1679     
;;;1680     tmpccer = TIMx->CCER;
;;;1681   
;;;1682     /* Set or Reset the CC2NP Bit */
;;;1683     tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
000002  f0220280          BIC      r2,r2,#0x80
;;;1684     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
000006  ea421101          ORR      r1,r2,r1,LSL #4
;;;1685   
;;;1686     /* Write to TIMx CCER register */
;;;1687     TIMx->CCER = tmpccer;
00000a  8401              STRH     r1,[r0,#0x20]
;;;1688   }
00000c  4770              BX       lr
;;;1689   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1644     */
;;;1645   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1646   {
;;;1647     uint16_t tmpccer = 0;
;;;1648   
;;;1649     /* Check the parameters */
;;;1650     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1651     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1652   
;;;1653     tmpccer = TIMx->CCER;
;;;1654   
;;;1655     /* Set or Reset the CC2P Bit */
;;;1656     tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
000002  f0220220          BIC      r2,r2,#0x20
;;;1657     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
000006  ea421101          ORR      r1,r2,r1,LSL #4
;;;1658   
;;;1659     /* Write to TIMx CCER register */
;;;1660     TIMx->CCER = tmpccer;
00000a  8401              STRH     r1,[r0,#0x20]
;;;1661   }
00000c  4770              BX       lr
;;;1662   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1265     */
;;;1266   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1267   {
;;;1268     uint16_t tmpccmr1 = 0;
;;;1269   
;;;1270     /* Check the parameters */
;;;1271     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1272     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1273   
;;;1274     tmpccmr1 = TIMx->CCMR1;
;;;1275   
;;;1276     /* Reset the OC2PE Bit */
;;;1277     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
000002  f4226200          BIC      r2,r2,#0x800
;;;1278   
;;;1279     /* Enable or Disable the Output Compare Preload feature */
;;;1280     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1281   
;;;1282     /* Write to TIMx CCMR1 register */
;;;1283     TIMx->CCMR1 = tmpccmr1;
00000a  8301              STRH     r1,[r0,#0x18]
;;;1284   }
00000c  4770              BX       lr
;;;1285   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1413     */
;;;1414   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1415   {
;;;1416     uint16_t tmpccmr2 = 0;
;;;1417     
;;;1418     /* Check the parameters */
;;;1419     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1420     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1421   
;;;1422     /* Get the TIMx CCMR2 register value */
;;;1423     tmpccmr2 = TIMx->CCMR2;
;;;1424   
;;;1425     /* Reset the OC3FE Bit */
;;;1426     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
000002  f0220204          BIC      r2,r2,#4
;;;1427   
;;;1428     /* Enable or Disable the Output Compare Fast Bit */
;;;1429     tmpccmr2 |= TIM_OCFast;
000006  430a              ORRS     r2,r2,r1
;;;1430   
;;;1431     /* Write to TIMx CCMR2 */
;;;1432     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1433   }
00000a  4770              BX       lr
;;;1434   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;832      */
;;;833    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;834    {
;;;835      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;836       
;;;837      /* Check the parameters */
;;;838      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;839      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;840      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;841      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;842    
;;;843      /* Disable the Channel 3: Reset the CC2E Bit */
;;;844      TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4227280          BIC      r2,r2,#0x100
000008  8402              STRH     r2,[r0,#0x20]
;;;845      
;;;846      /* Get the TIMx CCER register value */
;;;847      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;848      /* Get the TIMx CR2 register value */
;;;849      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;850      
;;;851      /* Get the TIMx CCMR2 register value */
;;;852      tmpccmrx = TIMx->CCMR2;
00000e  8b84              LDRH     r4,[r0,#0x1c]
;;;853        
;;;854      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;855      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
;;;856      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
;;;857      /* Select the Output Compare Mode */
;;;858      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
;;;859      
;;;860      /* Reset the Output Polarity level */
;;;861      tmpccer &= (uint16_t)~TIM_CCER_CC3P;
000010  f4227200          BIC      r2,r2,#0x200
000014  f0240573          BIC      r5,r4,#0x73           ;856
000018  880c              LDRH     r4,[r1,#0]            ;858
00001a  432c              ORRS     r4,r4,r5              ;858
;;;862      /* Set the Output Compare Polarity */
;;;863      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
00001c  898d              LDRH     r5,[r1,#0xc]
00001e  062d              LSLS     r5,r5,#24
000020  ea424515          ORR      r5,r2,r5,LSR #16
;;;864      
;;;865      /* Set the Output State */
;;;866      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
000024  884a              LDRH     r2,[r1,#2]
000026  0612              LSLS     r2,r2,#24
000028  ea454212          ORR      r2,r5,r2,LSR #16
;;;867        
;;;868      if((TIMx == TIM1) || (TIMx == TIM8))
00002c  4d10              LDR      r5,|L54.112|
00002e  42a8              CMP      r0,r5
000030  d002              BEQ      |L54.56|
000032  4d10              LDR      r5,|L54.116|
000034  42a8              CMP      r0,r5
000036  d115              BNE      |L54.100|
                  |L54.56|
;;;869      {
;;;870        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;871        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;872        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;873        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;874        
;;;875        /* Reset the Output N Polarity level */
;;;876        tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
000038  f4226500          BIC      r5,r2,#0x800
;;;877        /* Set the Output N Polarity */
;;;878        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
00003c  89ca              LDRH     r2,[r1,#0xe]
;;;879        /* Reset the Output N State */
;;;880        tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
;;;881        
;;;882        /* Set the Output N State */
;;;883        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
;;;884        /* Reset the Output Compare and Output Compare N IDLE State */
;;;885        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
;;;886        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
00003e  f4235340          BIC      r3,r3,#0x3000
000042  0612              LSLS     r2,r2,#24             ;878
000044  ea454212          ORR      r2,r5,r2,LSR #16      ;878
000048  f4226580          BIC      r5,r2,#0x400          ;880
00004c  888a              LDRH     r2,[r1,#4]            ;883
00004e  0612              LSLS     r2,r2,#24             ;883
000050  ea454212          ORR      r2,r5,r2,LSR #16      ;883
;;;887        /* Set the Output Idle state */
;;;888        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000054  8a0d              LDRH     r5,[r1,#0x10]
000056  052d              LSLS     r5,r5,#20
000058  ea434515          ORR      r5,r3,r5,LSR #16
;;;889        /* Set the Output N Idle state */
;;;890        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
00005c  8a4b              LDRH     r3,[r1,#0x12]
00005e  051b              LSLS     r3,r3,#20
000060  ea454313          ORR      r3,r5,r3,LSR #16
                  |L54.100|
;;;891      }
;;;892      /* Write to TIMx CR2 */
;;;893      TIMx->CR2 = tmpcr2;
000064  8083              STRH     r3,[r0,#4]
;;;894      
;;;895      /* Write to TIMx CCMR2 */
;;;896      TIMx->CCMR2 = tmpccmrx;
000066  8384              STRH     r4,[r0,#0x1c]
;;;897      
;;;898      /* Set the Capture Compare Register value */
;;;899      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000068  6889              LDR      r1,[r1,#8]
00006a  63c1              STR      r1,[r0,#0x3c]
;;;900      
;;;901      /* Write to TIMx CCER */
;;;902      TIMx->CCER = tmpccer;
00006c  8402              STRH     r2,[r0,#0x20]
;;;903    }
00006e  bd30              POP      {r4,r5,pc}
;;;904    
                          ENDP

                  |L54.112|
                          DCD      0x40010000
                  |L54.116|
                          DCD      0x40010400

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;1725     */
;;;1726   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1727   {
;;;1728     uint16_t tmpccer = 0;
;;;1729    
;;;1730     /* Check the parameters */
;;;1731     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1732     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1733       
;;;1734     tmpccer = TIMx->CCER;
;;;1735   
;;;1736     /* Set or Reset the CC3NP Bit */
;;;1737     tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
000002  f4226200          BIC      r2,r2,#0x800
;;;1738     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1739   
;;;1740     /* Write to TIMx CCER register */
;;;1741     TIMx->CCER = tmpccer;
00000a  8401              STRH     r1,[r0,#0x20]
;;;1742   }
00000c  4770              BX       lr
;;;1743   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1698     */
;;;1699   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1700   {
;;;1701     uint16_t tmpccer = 0;
;;;1702   
;;;1703     /* Check the parameters */
;;;1704     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1705     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1706   
;;;1707     tmpccer = TIMx->CCER;
;;;1708   
;;;1709     /* Set or Reset the CC3P Bit */
;;;1710     tmpccer &= (uint16_t)~TIM_CCER_CC3P;
000002  f4227200          BIC      r2,r2,#0x200
;;;1711     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1712   
;;;1713     /* Write to TIMx CCER register */
;;;1714     TIMx->CCER = tmpccer;
00000a  8401              STRH     r1,[r0,#0x20]
;;;1715   }
00000c  4770              BX       lr
;;;1716   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1294     */
;;;1295   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1296   {
;;;1297     uint16_t tmpccmr2 = 0;
;;;1298   
;;;1299     /* Check the parameters */
;;;1300     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1301     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1302   
;;;1303     tmpccmr2 = TIMx->CCMR2;
;;;1304   
;;;1305     /* Reset the OC3PE Bit */
;;;1306     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
000002  f0220208          BIC      r2,r2,#8
;;;1307   
;;;1308     /* Enable or Disable the Output Compare Preload feature */
;;;1309     tmpccmr2 |= TIM_OCPreload;
000006  430a              ORRS     r2,r2,r1
;;;1310   
;;;1311     /* Write to TIMx CCMR2 register */
;;;1312     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1313   }
00000a  4770              BX       lr
;;;1314   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1443     */
;;;1444   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1445   {
;;;1446     uint16_t tmpccmr2 = 0;
;;;1447   
;;;1448     /* Check the parameters */
;;;1449     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1450     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1451   
;;;1452     /* Get the TIMx CCMR2 register value */
;;;1453     tmpccmr2 = TIMx->CCMR2;
;;;1454   
;;;1455     /* Reset the OC4FE Bit */
;;;1456     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
000002  f4226280          BIC      r2,r2,#0x400
;;;1457   
;;;1458     /* Enable or Disable the Output Compare Fast Bit */
;;;1459     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1460   
;;;1461     /* Write to TIMx CCMR2 */
;;;1462     TIMx->CCMR2 = tmpccmr2;
00000a  8381              STRH     r1,[r0,#0x1c]
;;;1463   }
00000c  4770              BX       lr
;;;1464   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;912      */
;;;913    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;914    {
;;;915      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;916       
;;;917      /* Check the parameters */
;;;918      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;919      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;920      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;921      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;922    
;;;923      /* Disable the Channel 4: Reset the CC4E Bit */
;;;924      TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4225280          BIC      r2,r2,#0x1000
000008  8402              STRH     r2,[r0,#0x20]
;;;925      
;;;926      /* Get the TIMx CCER register value */
;;;927      tmpccer = TIMx->CCER;
00000a  8c03              LDRH     r3,[r0,#0x20]
;;;928      /* Get the TIMx CR2 register value */
;;;929      tmpcr2 =  TIMx->CR2;
00000c  8882              LDRH     r2,[r0,#4]
;;;930      
;;;931      /* Get the TIMx CCMR2 register value */
;;;932      tmpccmrx = TIMx->CCMR2;
00000e  8b84              LDRH     r4,[r0,#0x1c]
;;;933        
;;;934      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;935      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
;;;936      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
;;;937      
;;;938      /* Select the Output Compare Mode */
;;;939      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
;;;940      
;;;941      /* Reset the Output Polarity level */
;;;942      tmpccer &= (uint16_t)~TIM_CCER_CC4P;
;;;943      /* Set the Output Compare Polarity */
;;;944      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
;;;945      
;;;946      /* Set the Output State */
;;;947      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
000010  884d              LDRH     r5,[r1,#2]
000012  f4244ce6          BIC      r12,r4,#0x7300        ;936
000016  880c              LDRH     r4,[r1,#0]            ;939
000018  072d              LSLS     r5,r5,#28
00001a  0624              LSLS     r4,r4,#24             ;939
00001c  ea4c4414          ORR      r4,r12,r4,LSR #16     ;939
000020  f4235c00          BIC      r12,r3,#0x2000        ;942
000024  898b              LDRH     r3,[r1,#0xc]          ;944
000026  071b              LSLS     r3,r3,#28             ;944
000028  ea4c4313          ORR      r3,r12,r3,LSR #16     ;944
00002c  ea434515          ORR      r5,r3,r5,LSR #16
;;;948      
;;;949      if((TIMx == TIM1) || (TIMx == TIM8))
000030  4b08              LDR      r3,|L59.84|
000032  4298              CMP      r0,r3
000034  d002              BEQ      |L59.60|
000036  4b08              LDR      r3,|L59.88|
000038  4298              CMP      r0,r3
00003a  d105              BNE      |L59.72|
                  |L59.60|
;;;950      {
;;;951        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;952        /* Reset the Output Compare IDLE State */
;;;953        tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
00003c  f4224380          BIC      r3,r2,#0x4000
;;;954        /* Set the Output Idle state */
;;;955        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000040  8a0a              LDRH     r2,[r1,#0x10]
000042  0592              LSLS     r2,r2,#22
000044  ea434212          ORR      r2,r3,r2,LSR #16
                  |L59.72|
;;;956      }
;;;957      /* Write to TIMx CR2 */
;;;958      TIMx->CR2 = tmpcr2;
000048  8082              STRH     r2,[r0,#4]
;;;959      
;;;960      /* Write to TIMx CCMR2 */  
;;;961      TIMx->CCMR2 = tmpccmrx;
00004a  8384              STRH     r4,[r0,#0x1c]
;;;962        
;;;963      /* Set the Capture Compare Register value */
;;;964      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
00004c  6889              LDR      r1,[r1,#8]
00004e  6401              STR      r1,[r0,#0x40]
;;;965      
;;;966      /* Write to TIMx CCER */
;;;967      TIMx->CCER = tmpccer;
000050  8405              STRH     r5,[r0,#0x20]
;;;968    }
000052  bd30              POP      {r4,r5,pc}
;;;969    
                          ENDP

                  |L59.84|
                          DCD      0x40010000
                  |L59.88|
                          DCD      0x40010400

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1752     */
;;;1753   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1754   {
;;;1755     uint16_t tmpccer = 0;
;;;1756   
;;;1757     /* Check the parameters */
;;;1758     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1759     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1760   
;;;1761     tmpccer = TIMx->CCER;
;;;1762   
;;;1763     /* Set or Reset the CC4P Bit */
;;;1764     tmpccer &= (uint16_t)~TIM_CCER_CC4P;
000002  f4225200          BIC      r2,r2,#0x2000
;;;1765     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
000006  ea423101          ORR      r1,r2,r1,LSL #12
;;;1766   
;;;1767     /* Write to TIMx CCER register */
;;;1768     TIMx->CCER = tmpccer;
00000a  8401              STRH     r1,[r0,#0x20]
;;;1769   }
00000c  4770              BX       lr
;;;1770   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1323     */
;;;1324   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1325   {
;;;1326     uint16_t tmpccmr2 = 0;
;;;1327   
;;;1328     /* Check the parameters */
;;;1329     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1330     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1331   
;;;1332     tmpccmr2 = TIMx->CCMR2;
;;;1333   
;;;1334     /* Reset the OC4PE Bit */
;;;1335     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
000002  f4226200          BIC      r2,r2,#0x800
;;;1336   
;;;1337     /* Enable or Disable the Output Compare Preload feature */
;;;1338     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1339   
;;;1340     /* Write to TIMx CCMR2 register */
;;;1341     TIMx->CCMR2 = tmpccmr2;
00000a  8381              STRH     r1,[r0,#0x1c]
;;;1342   }
00000c  4770              BX       lr
;;;1343   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;975      */
;;;976    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;977    {
;;;978      /* Set the default configuration */
;;;979      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;980      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;981      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;982      TIM_OCInitStruct->TIM_Pulse = 0x00000000;
;;;983      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
000008  6081              STR      r1,[r0,#8]
00000a  8181              STRH     r1,[r0,#0xc]
;;;984      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  81c1              STRH     r1,[r0,#0xe]
;;;985      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8201              STRH     r1,[r0,#0x10]
;;;986      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  8241              STRH     r1,[r0,#0x12]
;;;987    }
000012  4770              BX       lr
;;;988    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;1970     */
;;;1971   void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1972   {
000004  460c              MOV      r4,r1
;;;1973     uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000006  2500              MOVS     r5,#0
;;;1974     uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
;;;1975   
;;;1976     /* Check the parameters */
;;;1977     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1978   
;;;1979     /* Select the Opposite Input Polarity */
;;;1980     if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
000008  8849              LDRH     r1,[r1,#2]
00000a  4607              MOV      r7,r0                 ;1972
00000c  2601              MOVS     r6,#1                 ;1974
00000e  b901              CBNZ     r1,|L63.18|
;;;1981     {
;;;1982       icoppositepolarity = TIM_ICPolarity_Falling;
000010  2502              MOVS     r5,#2
                  |L63.18|
;;;1983     }
;;;1984     else
;;;1985     {
;;;1986       icoppositepolarity = TIM_ICPolarity_Rising;
;;;1987     }
;;;1988     /* Select the Opposite Input */
;;;1989     if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000012  88a2              LDRH     r2,[r4,#4]
000014  2a01              CMP      r2,#1
000016  d100              BNE      |L63.26|
;;;1990     {
;;;1991       icoppositeselection = TIM_ICSelection_IndirectTI;
000018  2602              MOVS     r6,#2
                  |L63.26|
;;;1992     }
;;;1993     else
;;;1994     {
;;;1995       icoppositeselection = TIM_ICSelection_DirectTI;
;;;1996     }
;;;1997     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
00001a  8820              LDRH     r0,[r4,#0]
;;;1998     {
;;;1999       /* TI1 Configuration */
;;;2000       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
00001c  8923              LDRH     r3,[r4,#8]
00001e  2800              CMP      r0,#0                 ;1997
;;;2001                  TIM_ICInitStruct->TIM_ICFilter);
;;;2002       /* Set the Input Capture Prescaler value */
;;;2003       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;2004       /* TI2 Configuration */
;;;2005       TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
;;;2006       /* Set the Input Capture Prescaler value */
;;;2007       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;2008     }
;;;2009     else
;;;2010     { 
;;;2011       /* TI2 Configuration */
;;;2012       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000020  4638              MOV      r0,r7
000022  d011              BEQ      |L63.72|
000024  f7fffffe          BL       TI2_Config
;;;2013                  TIM_ICInitStruct->TIM_ICFilter);
;;;2014       /* Set the Input Capture Prescaler value */
;;;2015       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000028  88e1              LDRH     r1,[r4,#6]
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       TIM_SetIC2Prescaler
;;;2016       /* TI1 Configuration */
;;;2017       TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000030  8923              LDRH     r3,[r4,#8]
000032  4632              MOV      r2,r6
000034  4629              MOV      r1,r5
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       TI1_Config
;;;2018       /* Set the Input Capture Prescaler value */
;;;2019       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00003c  88e1              LDRH     r1,[r4,#6]
00003e  4638              MOV      r0,r7
000040  e8bd41f0          POP      {r4-r8,lr}
000044  f7ffbffe          B.W      TIM_SetIC1Prescaler
                  |L63.72|
000048  f7fffffe          BL       TI1_Config
00004c  88e1              LDRH     r1,[r4,#6]            ;2003
00004e  4638              MOV      r0,r7                 ;2003
000050  f7fffffe          BL       TIM_SetIC1Prescaler
000054  8923              LDRH     r3,[r4,#8]            ;2005
000056  4632              MOV      r2,r6                 ;2005
000058  4629              MOV      r1,r5                 ;2005
00005a  4638              MOV      r0,r7                 ;2005
00005c  f7fffffe          BL       TI2_Config
000060  88e1              LDRH     r1,[r4,#6]            ;2007
000062  4638              MOV      r0,r7                 ;2007
000064  e8bd41f0          POP      {r4-r8,lr}            ;2007
000068  f7ffbffe          B.W      TIM_SetIC2Prescaler
;;;2020     }
;;;2021   }
;;;2022   
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;359      */
;;;360    void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;361    {
;;;362      /* Check the parameters */
;;;363      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;364      assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;365      /* Set the Prescaler value */
;;;366      TIMx->PSC = Prescaler;
;;;367      /* Set or reset the UG Bit */
;;;368      TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;369    }
000004  4770              BX       lr
;;;370    
                          ENDP


                          AREA ||i.TIM_RemapConfig||, CODE, READONLY, ALIGN=1

                  TIM_RemapConfig PROC
;;;3165     */
;;;3166   void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
000000  f8a01050          STRH     r1,[r0,#0x50]
;;;3167   {
;;;3168    /* Check the parameters */
;;;3169     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;3170     assert_param(IS_TIM_REMAP(TIM_Remap));
;;;3171   
;;;3172     /* Set the Timer remapping configuration */
;;;3173     TIMx->OR =  TIM_Remap;
;;;3174   }
000004  4770              BX       lr
;;;3175   /**
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;2639     */
;;;2640   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2641   {
;;;2642     /* Check the parameters */
;;;2643     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2644     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2645   
;;;2646     if (NewState != DISABLE)
;;;2647     {
;;;2648       /* Set the CCDS Bit */
;;;2649       TIMx->CR2 |= TIM_CR2_CCDS;
;;;2650     }
;;;2651     else
;;;2652     {
;;;2653       /* Reset the CCDS Bit */
;;;2654       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L66.12|
000006  f0410108          ORR      r1,r1,#8              ;2649
00000a  e001              B        |L66.16|
                  |L66.12|
00000c  f0210108          BIC      r1,r1,#8
                  |L66.16|
000010  8081              STRH     r1,[r0,#4]            ;2649
;;;2655     }
;;;2656   }
000012  4770              BX       lr
;;;2657   /**
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;2285     */
;;;2286   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2287   {
;;;2288     /* Check the parameters */
;;;2289     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2290     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2291   
;;;2292     if (NewState != DISABLE)
;;;2293     {
;;;2294       /* Set the COM Bit */
;;;2295       TIMx->CR2 |= TIM_CR2_CCUS;
;;;2296     }
;;;2297     else
;;;2298     {
;;;2299       /* Reset the COM Bit */
;;;2300       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L67.12|
000006  f0410104          ORR      r1,r1,#4              ;2295
00000a  e001              B        |L67.16|
                  |L67.12|
00000c  f0210104          BIC      r1,r1,#4
                  |L67.16|
000010  8081              STRH     r1,[r0,#4]            ;2295
;;;2301     }
;;;2302   }
000012  4770              BX       lr
;;;2303   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;3114     */
;;;3115   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;3116   {
;;;3117     /* Check the parameters */
;;;3118     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3119     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3120   
;;;3121     if (NewState != DISABLE)
;;;3122     {
;;;3123       /* Set the TI1S Bit */
;;;3124       TIMx->CR2 |= TIM_CR2_TI1S;
;;;3125     }
;;;3126     else
;;;3127     {
;;;3128       /* Reset the TI1S Bit */
;;;3129       TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L68.12|
000006  f0410180          ORR      r1,r1,#0x80           ;3124
00000a  e001              B        |L68.16|
                  |L68.12|
00000c  f0210180          BIC      r1,r1,#0x80
                  |L68.16|
000010  8081              STRH     r1,[r0,#4]            ;3124
;;;3130     }
;;;3131   }
000012  4770              BX       lr
;;;3132   /**
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;2884     */
;;;2885   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  8902              LDRH     r2,[r0,#8]
;;;2886   {
;;;2887     uint16_t tmpsmcr = 0;
;;;2888   
;;;2889     /* Check the parameters */
;;;2890     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;2891     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2892   
;;;2893     /* Get the TIMx SMCR register value */
;;;2894     tmpsmcr = TIMx->SMCR;
;;;2895   
;;;2896     /* Reset the TS Bits */
;;;2897     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
000002  f0220270          BIC      r2,r2,#0x70
;;;2898   
;;;2899     /* Set the Input Trigger source */
;;;2900     tmpsmcr |= TIM_InputTriggerSource;
000006  430a              ORRS     r2,r2,r1
;;;2901   
;;;2902     /* Write to TIMx SMCR */
;;;2903     TIMx->SMCR = tmpsmcr;
000008  8102              STRH     r2,[r0,#8]
;;;2904   }
00000a  4770              BX       lr
;;;2905   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2974     */
;;;2975   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2976   {
;;;2977     /* Check the parameters */
;;;2978     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2979     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2980   
;;;2981     /* Reset the MSM Bit */
;;;2982     TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
000002  f0220280          BIC      r2,r2,#0x80
000006  8102              STRH     r2,[r0,#8]
;;;2983     
;;;2984     /* Set or Reset the MSM Bit */
;;;2985     TIMx->SMCR |= TIM_MasterSlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;2986   }
00000e  4770              BX       lr
;;;2987   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;1011     */
;;;1012   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b530              PUSH     {r4,r5,lr}
;;;1013   {
;;;1014     uint32_t tmp = 0;
;;;1015     uint16_t tmp1 = 0;
;;;1016   
;;;1017     /* Check the parameters */
;;;1018     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1019     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1020     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;1021   
;;;1022     tmp = (uint32_t) TIMx;
;;;1023     tmp += CCMR_OFFSET;
;;;1024   
;;;1025     tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
000002  2401              MOVS     r4,#1
;;;1026   
;;;1027     /* Disable the Channel: Reset the CCxE Bit */
;;;1028     TIMx->CCER &= (uint16_t) ~tmp1;
000004  8c05              LDRH     r5,[r0,#0x20]
000006  f1000318          ADD      r3,r0,#0x18           ;1023
00000a  408c              LSLS     r4,r4,r1              ;1025
00000c  43a5              BICS     r5,r5,r4
00000e  8405              STRH     r5,[r0,#0x20]
;;;1029   
;;;1030     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000010  b181              CBZ      r1,|L71.52|
000012  2908              CMP      r1,#8
000014  d00e              BEQ      |L71.52|
;;;1031     {
;;;1032       tmp += (TIM_Channel>>1);
;;;1033   
;;;1034       /* Reset the OCxM bits in the CCMRx register */
;;;1035       *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
;;;1036      
;;;1037       /* Configure the OCxM bits in the CCMRx register */
;;;1038       *(__IO uint32_t *) tmp |= TIM_OCMode;
;;;1039     }
;;;1040     else
;;;1041     {
;;;1042       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000016  1f09              SUBS     r1,r1,#4
000018  b288              UXTH     r0,r1
00001a  eb030050          ADD      r0,r3,r0,LSR #1
;;;1043   
;;;1044       /* Reset the OCxM bits in the CCMRx register */
;;;1045       *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
00001e  6801              LDR      r1,[r0,#0]
000020  f64873ff          MOV      r3,#0x8fff
000024  4019              ANDS     r1,r1,r3
000026  6001              STR      r1,[r0,#0]
;;;1046       
;;;1047       /* Configure the OCxM bits in the CCMRx register */
;;;1048       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000028  6801              LDR      r1,[r0,#0]
00002a  0612              LSLS     r2,r2,#24
00002c  0c12              LSRS     r2,r2,#16
                  |L71.46|
00002e  4311              ORRS     r1,r1,r2              ;1038
000030  6001              STR      r1,[r0,#0]            ;1038
;;;1049     }
;;;1050   }
000032  bd30              POP      {r4,r5,pc}
                  |L71.52|
000034  eb030051          ADD      r0,r3,r1,LSR #1       ;1032
000038  6801              LDR      r1,[r0,#0]            ;1035
00003a  f64f738f          MOV      r3,#0xff8f            ;1035
00003e  4019              ANDS     r1,r1,r3              ;1035
000040  6001              STR      r1,[r0,#0]            ;1035
000042  6801              LDR      r1,[r0,#0]            ;1038
000044  e7f3              B        |L71.46|
;;;1051   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;548      */
;;;549    void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;550    {
;;;551      /* Check the parameters */
;;;552      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;553      assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;554    
;;;555      /* Reset the OPM Bit */
;;;556      TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
000002  f0220208          BIC      r2,r2,#8
000006  8002              STRH     r2,[r0,#0]
;;;557    
;;;558      /* Configure the OPM Mode */
;;;559      TIMx->CR1 |= TIM_OPMode;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;560    }
00000e  4770              BX       lr
;;;561    
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2927     */
;;;2928   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2929   {
;;;2930     /* Check the parameters */
;;;2931     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;2932     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2933   
;;;2934     /* Reset the MMS Bits */
;;;2935     TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
000002  f0220270          BIC      r2,r2,#0x70
000006  8082              STRH     r2,[r0,#4]
;;;2936     /* Select the TRGO source */
;;;2937     TIMx->CR2 |=  TIM_TRGOSource;
000008  8882              LDRH     r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  8082              STRH     r2,[r0,#4]
;;;2938   }
00000e  4770              BX       lr
;;;2939   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2951     */
;;;2952   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2953   {
;;;2954     /* Check the parameters */
;;;2955     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2956     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2957   
;;;2958     /* Reset the SMS Bits */
;;;2959     TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
000002  f0220207          BIC      r2,r2,#7
000006  8102              STRH     r2,[r0,#8]
;;;2960   
;;;2961     /* Select the Slave Mode */
;;;2962     TIMx->SMCR |= TIM_SlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;2963   }
00000e  4770              BX       lr
;;;2964   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;423      */
;;;424    void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
000000  62c1              STR      r1,[r0,#0x2c]
;;;425    {
;;;426      /* Check the parameters */
;;;427      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;428      
;;;429      /* Set the Autoreload Register value */
;;;430      TIMx->ARR = Autoreload;
;;;431    }
000002  4770              BX       lr
;;;432    
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;571      */
;;;572    void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;573    {
;;;574      /* Check the parameters */
;;;575      assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;576      assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;577    
;;;578      /* Reset the CKD Bits */
;;;579      TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
000002  f4227240          BIC      r2,r2,#0x300
000006  8002              STRH     r2,[r0,#0]
;;;580    
;;;581      /* Set the CKD value */
;;;582      TIMx->CR1 |= TIM_CKD;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;583    }
00000e  4770              BX       lr
;;;584    
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;1057     */
;;;1058   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
000000  6341              STR      r1,[r0,#0x34]
;;;1059   {
;;;1060     /* Check the parameters */
;;;1061     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1062   
;;;1063     /* Set the Capture Compare1 Register value */
;;;1064     TIMx->CCR1 = Compare1;
;;;1065   }
000002  4770              BX       lr
;;;1066   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;1073     */
;;;1074   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
000000  6381              STR      r1,[r0,#0x38]
;;;1075   {
;;;1076     /* Check the parameters */
;;;1077     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1078   
;;;1079     /* Set the Capture Compare2 Register value */
;;;1080     TIMx->CCR2 = Compare2;
;;;1081   }
000002  4770              BX       lr
;;;1082   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;1088     */
;;;1089   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
000000  63c1              STR      r1,[r0,#0x3c]
;;;1090   {
;;;1091     /* Check the parameters */
;;;1092     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1093   
;;;1094     /* Set the Capture Compare3 Register value */
;;;1095     TIMx->CCR3 = Compare3;
;;;1096   }
000002  4770              BX       lr
;;;1097   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;1103     */
;;;1104   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
000000  6401              STR      r1,[r0,#0x40]
;;;1105   {
;;;1106     /* Check the parameters */
;;;1107     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1108   
;;;1109     /* Set the Capture Compare4 Register value */
;;;1110     TIMx->CCR4 = Compare4;
;;;1111   }
000002  4770              BX       lr
;;;1112   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;408      */
;;;409    void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
000000  6241              STR      r1,[r0,#0x24]
;;;410    {
;;;411      /* Check the parameters */
;;;412       assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;413    
;;;414      /* Set the Counter Register value */
;;;415      TIMx->CNT = Counter;
;;;416    }
000002  4770              BX       lr
;;;417    
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2090     */
;;;2091   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2092   {
;;;2093     /* Check the parameters */
;;;2094     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2095     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2096   
;;;2097     /* Reset the IC1PSC Bits */
;;;2098     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
000002  f022020c          BIC      r2,r2,#0xc
000006  8302              STRH     r2,[r0,#0x18]
;;;2099   
;;;2100     /* Set the IC1PSC value */
;;;2101     TIMx->CCMR1 |= TIM_ICPSC;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;2102   }
00000e  4770              BX       lr
;;;2103   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2115     */
;;;2116   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2117   {
;;;2118     /* Check the parameters */
;;;2119     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2120     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2121   
;;;2122     /* Reset the IC2PSC Bits */
;;;2123     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
000002  f4226240          BIC      r2,r2,#0xc00
000006  8302              STRH     r2,[r0,#0x18]
;;;2124   
;;;2125     /* Set the IC2PSC value */
;;;2126     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  ea422201          ORR      r2,r2,r1,LSL #8
00000e  8302              STRH     r2,[r0,#0x18]
;;;2127   }
000010  4770              BX       lr
;;;2128   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2139     */
;;;2140   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2141   {
;;;2142     /* Check the parameters */
;;;2143     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2144     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2145   
;;;2146     /* Reset the IC3PSC Bits */
;;;2147     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
000002  f022020c          BIC      r2,r2,#0xc
000006  8382              STRH     r2,[r0,#0x1c]
;;;2148   
;;;2149     /* Set the IC3PSC value */
;;;2150     TIMx->CCMR2 |= TIM_ICPSC;
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  430a              ORRS     r2,r2,r1
00000c  8382              STRH     r2,[r0,#0x1c]
;;;2151   }
00000e  4770              BX       lr
;;;2152   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2163     */
;;;2164   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2165   {  
;;;2166     /* Check the parameters */
;;;2167     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2168     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2169   
;;;2170     /* Reset the IC4PSC Bits */
;;;2171     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
000002  f4226240          BIC      r2,r2,#0xc00
000006  8382              STRH     r2,[r0,#0x1c]
;;;2172   
;;;2173     /* Set the IC4PSC value */
;;;2174     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  ea422201          ORR      r2,r2,r1,LSL #8
00000e  8382              STRH     r2,[r0,#0x1c]
;;;2175   }
000010  4770              BX       lr
;;;2176   /**
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;2729     */
;;;2730   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  b570              PUSH     {r4-r6,lr}
;;;2731                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;2732   {
000002  460d              MOV      r5,r1
000004  4611              MOV      r1,r2
000006  4604              MOV      r4,r0
;;;2733     /* Check the parameters */
;;;2734     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2735     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;2736     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;2737   
;;;2738     /* Configure the Timer Input Clock Source */
;;;2739     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
000008  2d60              CMP      r5,#0x60
;;;2740     {
;;;2741       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;2742     }
;;;2743     else
;;;2744     {
;;;2745       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00000a  f04f0201          MOV      r2,#1
00000e  d00a              BEQ      |L86.38|
000010  f7fffffe          BL       TI1_Config
                  |L86.20|
;;;2746     }
;;;2747     /* Select the Trigger source */
;;;2748     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       TIM_SelectInputTrigger
;;;2749     /* Select the External clock mode1 */
;;;2750     TIMx->SMCR |= TIM_SlaveMode_External1;
00001c  8920              LDRH     r0,[r4,#8]
00001e  f0400007          ORR      r0,r0,#7
000022  8120              STRH     r0,[r4,#8]
;;;2751   }
000024  bd70              POP      {r4-r6,pc}
                  |L86.38|
000026  f7fffffe          BL       TI2_Config
00002a  e7f3              B        |L86.20|
;;;2752   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;287      */
;;;288    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;289    {
;;;290      uint16_t tmpcr1 = 0;
;;;291    
;;;292      /* Check the parameters */
;;;293      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;294      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;295      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;296    
;;;297      tmpcr1 = TIMx->CR1;  
000002  8802              LDRH     r2,[r0,#0]
;;;298    
;;;299      if((TIMx == TIM1) || (TIMx == TIM8)||
000004  4b17              LDR      r3,|L87.100|
000006  4c18              LDR      r4,|L87.104|
000008  4298              CMP      r0,r3
00000a  d00d              BEQ      |L87.40|
00000c  42a0              CMP      r0,r4
00000e  d00b              BEQ      |L87.40|
;;;300         (TIMx == TIM2) || (TIMx == TIM3)||
000010  f1b04f80          CMP      r0,#0x40000000
000014  d008              BEQ      |L87.40|
000016  4d15              LDR      r5,|L87.108|
000018  42a8              CMP      r0,r5
00001a  d005              BEQ      |L87.40|
;;;301         (TIMx == TIM4) || (TIMx == TIM5)) 
00001c  4d14              LDR      r5,|L87.112|
00001e  42a8              CMP      r0,r5
000020  d002              BEQ      |L87.40|
000022  4d14              LDR      r5,|L87.116|
000024  42a8              CMP      r0,r5
000026  d104              BNE      |L87.50|
                  |L87.40|
;;;302      {
;;;303        /* Select the Counter Mode */
;;;304        tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
000028  f0220c70          BIC      r12,r2,#0x70
;;;305        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
00002c  884a              LDRH     r2,[r1,#2]
00002e  ea42020c          ORR      r2,r2,r12
                  |L87.50|
;;;306      }
;;;307     
;;;308      if((TIMx != TIM6) && (TIMx != TIM7))
000032  4d11              LDR      r5,|L87.120|
000034  42a8              CMP      r0,r5
000036  d007              BEQ      |L87.72|
000038  4d10              LDR      r5,|L87.124|
00003a  42a8              CMP      r0,r5
00003c  d004              BEQ      |L87.72|
;;;309      {
;;;310        /* Set the clock division */
;;;311        tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
00003e  f4227c40          BIC      r12,r2,#0x300
;;;312        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
000042  890a              LDRH     r2,[r1,#8]
000044  ea42020c          ORR      r2,r2,r12
                  |L87.72|
;;;313      }
;;;314    
;;;315      TIMx->CR1 = tmpcr1;
000048  8002              STRH     r2,[r0,#0]
;;;316    
;;;317      /* Set the Autoreload value */
;;;318      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
00004a  684a              LDR      r2,[r1,#4]
00004c  62c2              STR      r2,[r0,#0x2c]
;;;319     
;;;320      /* Set the Prescaler value */
;;;321      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
00004e  880a              LDRH     r2,[r1,#0]
000050  8502              STRH     r2,[r0,#0x28]
;;;322        
;;;323      if ((TIMx == TIM1) || (TIMx == TIM8))  
000052  4298              CMP      r0,r3
000054  d001              BEQ      |L87.90|
000056  42a0              CMP      r0,r4
000058  d101              BNE      |L87.94|
                  |L87.90|
;;;324      {
;;;325        /* Set the Repetition Counter value */
;;;326        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
00005a  7a89              LDRB     r1,[r1,#0xa]
00005c  8601              STRH     r1,[r0,#0x30]
                  |L87.94|
;;;327      }
;;;328    
;;;329      /* Generate an update event to reload the Prescaler 
;;;330         and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;331      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
00005e  2101              MOVS     r1,#1
000060  8281              STRH     r1,[r0,#0x14]
;;;332    }
000062  bd30              POP      {r4,r5,pc}
;;;333    
                          ENDP

                  |L87.100|
                          DCD      0x40010000
                  |L87.104|
                          DCD      0x40010400
                  |L87.108|
                          DCD      0x40000400
                  |L87.112|
                          DCD      0x40000800
                  |L87.116|
                          DCD      0x40000c00
                  |L87.120|
                          DCD      0x40001000
                  |L87.124|
                          DCD      0x40001400

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;339      */
;;;340    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f04f31ff          MOV      r1,#0xffffffff
;;;341    {
;;;342      /* Set the default configuration */
;;;343      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
;;;344      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000004  6041              STR      r1,[r0,#4]
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;345      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  8101              STRH     r1,[r0,#8]
;;;346      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;347      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7281              STRB     r1,[r0,#0xa]
;;;348    }
000010  4770              BX       lr
;;;349    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;467      */
;;;468    void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;469    {
;;;470      /* Check the parameters */
;;;471      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;472      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;473    
;;;474      if (NewState != DISABLE)
;;;475      {
;;;476        /* Set the Update Disable Bit */
;;;477        TIMx->CR1 |= TIM_CR1_UDIS;
;;;478      }
;;;479      else
;;;480      {
;;;481        /* Reset the Update Disable Bit */
;;;482        TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L89.12|
000006  f0410102          ORR      r1,r1,#2              ;477
00000a  e001              B        |L89.16|
                  |L89.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L89.16|
000010  8001              STRH     r1,[r0,#0]            ;477
;;;483      }
;;;484    }
000012  4770              BX       lr
;;;485    
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;496      */
;;;497    void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  2900              CMP      r1,#0
;;;498    {
;;;499      /* Check the parameters */
;;;500      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;501      assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;502    
;;;503      if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;504      {
;;;505        /* Set the URS Bit */
;;;506        TIMx->CR1 |= TIM_CR1_URS;
;;;507      }
;;;508      else
;;;509      {
;;;510        /* Reset the URS Bit */
;;;511        TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L90.12|
000006  f0410104          ORR      r1,r1,#4              ;506
00000a  e001              B        |L90.16|
                  |L90.12|
00000c  f0210104          BIC      r1,r1,#4
                  |L90.16|
000010  8001              STRH     r1,[r0,#0]            ;506
;;;512      }
;;;513    }
000012  4770              BX       lr
;;;514    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_tim.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_tim_c_c458916b____REV16|
#line 114 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_tim_c_c458916b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_tim_c_c458916b____REVSH|
#line 128
|__asm___15_stm32f4xx_tim_c_c458916b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
