; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\STM324xG-EVAL\stm32f4xx_fsmc.o --asm_dir=.\STM324xG-EVAL\ --list_dir=.\STM324xG-EVAL\ --depend=.\STM324xG-EVAL\stm32f4xx_fsmc.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -I..\ -I..\inc -I..\..\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\..\..\Utilities\STM32_EVAL -I..\..\..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F4XX -DUSE_STM324xG_EVAL --omf_browse=.\STM324xG-EVAL\stm32f4xx_fsmc.crf ..\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fsmc.c]
                          THUMB

                          AREA ||i.FSMC_ClearFlag||, CODE, READONLY, ALIGN=1

                  FSMC_ClearFlag PROC
;;;863      */
;;;864    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  f04f4220          MOV      r2,#0xa0000000
;;;865    {
;;;866     /* Check the parameters */
;;;867      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;868      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;869        
;;;870      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d009              BEQ      |L1.28|
;;;871      {
;;;872        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
;;;873      }  
;;;874      else if(FSMC_Bank == FSMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d00a              BEQ      |L1.36|
00000e  f10202a4          ADD      r2,r2,#0xa4
                  |L1.18|
;;;875      {
;;;876        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
;;;877      }
;;;878      /* FSMC_Bank4_PCCARD*/
;;;879      else
;;;880      {
;;;881        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
000012  6810              LDR      r0,[r2,#0]
000014  ea200001          BIC      r0,r0,r1
000018  6010              STR      r0,[r2,#0]
;;;882      }
;;;883    }
00001a  4770              BX       lr
                  |L1.28|
00001c  6e50              LDR      r0,[r2,#0x64]         ;872
00001e  4388              BICS     r0,r0,r1              ;872
000020  6650              STR      r0,[r2,#0x64]         ;872
000022  4770              BX       lr
                  |L1.36|
000024  f1020284          ADD      r2,r2,#0x84
000028  e7f3              B        |L1.18|
;;;884    
                          ENDP


                          AREA ||i.FSMC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  FSMC_ClearITPendingBit PROC
;;;949      */
;;;950    void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  f04f4220          MOV      r2,#0xa0000000
;;;951    {
;;;952      /* Check the parameters */
;;;953      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;954      assert_param(IS_FSMC_IT(FSMC_IT));
;;;955        
;;;956      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d009              BEQ      |L2.28|
;;;957      {
;;;958        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
;;;959      }  
;;;960      else if(FSMC_Bank == FSMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d00b              BEQ      |L2.38|
00000e  f10202a4          ADD      r2,r2,#0xa4
                  |L2.18|
;;;961      {
;;;962        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
;;;963      }
;;;964      /* FSMC_Bank4_PCCARD*/
;;;965      else
;;;966      {
;;;967        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
000012  6810              LDR      r0,[r2,#0]
000014  ea2000d1          BIC      r0,r0,r1,LSR #3
000018  6010              STR      r0,[r2,#0]
;;;968      }
;;;969    }
00001a  4770              BX       lr
                  |L2.28|
00001c  6e50              LDR      r0,[r2,#0x64]         ;958
00001e  ea2000d1          BIC      r0,r0,r1,LSR #3       ;958
000022  6650              STR      r0,[r2,#0x64]         ;958
000024  4770              BX       lr
                  |L2.38|
000026  f1020284          ADD      r2,r2,#0x84
00002a  e7f2              B        |L2.18|
;;;970    
                          ENDP


                          AREA ||i.FSMC_GetECC||, CODE, READONLY, ALIGN=1

                  FSMC_GetECC PROC
;;;547      */
;;;548    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
000000  f04f4120          MOV      r1,#0xa0000000
;;;549    {
;;;550      uint32_t eccval = 0x00000000;
;;;551      
;;;552      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d002              BEQ      |L3.14|
;;;553      {
;;;554        /* Get the ECCR2 register value */
;;;555        eccval = FSMC_Bank2->ECCR2;
;;;556      }
;;;557      else
;;;558      {
;;;559        /* Get the ECCR3 register value */
;;;560        eccval = FSMC_Bank3->ECCR3;
000008  f8d10094          LDR      r0,[r1,#0x94]
;;;561      }
;;;562      /* Return the error correction code value */
;;;563      return(eccval);
;;;564    }
00000c  4770              BX       lr
                  |L3.14|
00000e  6f48              LDR      r0,[r1,#0x74]         ;555
000010  4770              BX       lr
;;;565    /**
                          ENDP


                          AREA ||i.FSMC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetFlagStatus PROC
;;;813      */
;;;814    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  4602              MOV      r2,r0
;;;815    {
;;;816      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;817      uint32_t tmpsr = 0x00000000;
;;;818      
;;;819      /* Check the parameters */
;;;820      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;821      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;822      
;;;823      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;824      {
;;;825        tmpsr = FSMC_Bank2->SR2;
000004  f04f4320          MOV      r3,#0xa0000000
000008  2a10              CMP      r2,#0x10              ;823
00000a  d008              BEQ      |L4.30|
;;;826      }  
;;;827      else if(FSMC_Bank == FSMC_Bank3_NAND)
00000c  f5b27f80          CMP      r2,#0x100
000010  d007              BEQ      |L4.34|
;;;828      {
;;;829        tmpsr = FSMC_Bank3->SR3;
;;;830      }
;;;831      /* FSMC_Bank4_PCCARD*/
;;;832      else
;;;833      {
;;;834        tmpsr = FSMC_Bank4->SR4;
000012  f8d320a4          LDR      r2,[r3,#0xa4]
                  |L4.22|
;;;835      } 
;;;836      
;;;837      /* Get the flag status */
;;;838      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
000016  420a              TST      r2,r1
000018  d000              BEQ      |L4.28|
;;;839      {
;;;840        bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L4.28|
;;;841      }
;;;842      else
;;;843      {
;;;844        bitstatus = RESET;
;;;845      }
;;;846      /* Return the flag status */
;;;847      return bitstatus;
;;;848    }
00001c  4770              BX       lr
                  |L4.30|
00001e  6e5a              LDR      r2,[r3,#0x64]         ;825
000020  e7f9              B        |L4.22|
                  |L4.34|
000022  f8d32084          LDR      r2,[r3,#0x84]         ;829
000026  e7f6              B        |L4.22|
;;;849    
                          ENDP


                          AREA ||i.FSMC_GetITStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetITStatus PROC
;;;898      */
;;;899    ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  4602              MOV      r2,r0
;;;900    {
;;;901      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;902      uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
;;;903      
;;;904      /* Check the parameters */
;;;905      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;906      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;907      
;;;908      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;909      {
;;;910        tmpsr = FSMC_Bank2->SR2;
000004  f04f4320          MOV      r3,#0xa0000000
000008  2a10              CMP      r2,#0x10              ;908
00000a  d00c              BEQ      |L5.38|
;;;911      }  
;;;912      else if(FSMC_Bank == FSMC_Bank3_NAND)
00000c  f5b27f80          CMP      r2,#0x100
000010  d00b              BEQ      |L5.42|
;;;913      {
;;;914        tmpsr = FSMC_Bank3->SR3;
;;;915      }
;;;916      /* FSMC_Bank4_PCCARD*/
;;;917      else
;;;918      {
;;;919        tmpsr = FSMC_Bank4->SR4;
000012  f8d320a4          LDR      r2,[r3,#0xa4]
                  |L5.22|
;;;920      } 
;;;921      
;;;922      itstatus = tmpsr & FSMC_IT;
000016  420a              TST      r2,r1
;;;923      
;;;924      itenable = tmpsr & (FSMC_IT >> 3);
000018  ea0201d1          AND      r1,r2,r1,LSR #3
;;;925      if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
00001c  d002              BEQ      |L5.36|
00001e  2900              CMP      r1,#0
000020  d000              BEQ      |L5.36|
;;;926      {
;;;927        bitstatus = SET;
000022  2001              MOVS     r0,#1
                  |L5.36|
;;;928      }
;;;929      else
;;;930      {
;;;931        bitstatus = RESET;
;;;932      }
;;;933      return bitstatus; 
;;;934    }
000024  4770              BX       lr
                  |L5.38|
000026  6e5a              LDR      r2,[r3,#0x64]         ;910
000028  e7f5              B        |L5.22|
                  |L5.42|
00002a  f8d32084          LDR      r2,[r3,#0x84]         ;914
00002e  e7f2              B        |L5.22|
;;;935    
                          ENDP


                          AREA ||i.FSMC_ITConfig||, CODE, READONLY, ALIGN=1

                  FSMC_ITConfig PROC
;;;753      */
;;;754    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;755    {
;;;756      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;757      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;758      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;759      
;;;760      if (NewState != DISABLE)
;;;761      {
;;;762        /* Enable the selected FSMC_Bank2 interrupts */
;;;763        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;764        {
;;;765          FSMC_Bank2->SR2 |= FSMC_IT;
;;;766        }
;;;767        /* Enable the selected FSMC_Bank3 interrupts */
;;;768        else if (FSMC_Bank == FSMC_Bank3_NAND)
000002  f44f7480          MOV      r4,#0x100
000006  f04f4320          MOV      r3,#0xa0000000        ;765
00000a  b182              CBZ      r2,|L6.46|
00000c  2810              CMP      r0,#0x10              ;763
00000e  d004              BEQ      |L6.26|
000010  42a0              CMP      r0,r4
000012  d105              BNE      |L6.32|
000014  f1030384          ADD      r3,r3,#0x84
;;;769        {
;;;770          FSMC_Bank3->SR3 |= FSMC_IT;
000018  e004              B        |L6.36|
                  |L6.26|
00001a  6e58              LDR      r0,[r3,#0x64]         ;765
00001c  4308              ORRS     r0,r0,r1              ;765
00001e  e00f              B        |L6.64|
                  |L6.32|
000020  f10303a4          ADD      r3,r3,#0xa4           ;765
                  |L6.36|
;;;771        }
;;;772        /* Enable the selected FSMC_Bank4 interrupts */
;;;773        else
;;;774        {
;;;775          FSMC_Bank4->SR4 |= FSMC_IT;    
000024  6818              LDR      r0,[r3,#0]
000026  ea400001          ORR      r0,r0,r1
                  |L6.42|
00002a  6018              STR      r0,[r3,#0]
;;;776        }
;;;777      }
;;;778      else
;;;779      {
;;;780        /* Disable the selected FSMC_Bank2 interrupts */
;;;781        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;782        {
;;;783          
;;;784          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
;;;785        }
;;;786        /* Disable the selected FSMC_Bank3 interrupts */
;;;787        else if (FSMC_Bank == FSMC_Bank3_NAND)
;;;788        {
;;;789          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
;;;790        }
;;;791        /* Disable the selected FSMC_Bank4 interrupts */
;;;792        else
;;;793        {
;;;794          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
;;;795        }
;;;796      }
;;;797    }
00002c  bd10              POP      {r4,pc}
                  |L6.46|
00002e  2810              CMP      r0,#0x10              ;781
000030  d004              BEQ      |L6.60|
000032  42a0              CMP      r0,r4                 ;787
000034  d106              BNE      |L6.68|
000036  f1030384          ADD      r3,r3,#0x84           ;787
00003a  e005              B        |L6.72|
                  |L6.60|
00003c  6e58              LDR      r0,[r3,#0x64]         ;784
00003e  4388              BICS     r0,r0,r1              ;784
                  |L6.64|
000040  6658              STR      r0,[r3,#0x64]         ;765
000042  bd10              POP      {r4,pc}
                  |L6.68|
000044  f10303a4          ADD      r3,r3,#0xa4
                  |L6.72|
000048  6818              LDR      r0,[r3,#0]            ;789
00004a  ea200001          BIC      r0,r0,r1              ;789
00004e  e7ec              B        |L6.42|
;;;798    
                          ENDP


                          AREA ||i.FSMC_NANDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDCmd PROC
;;;468      */
;;;469    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;470    {
;;;471      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;472      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;473      
;;;474      if (NewState != DISABLE)
000004  b151              CBZ      r1,|L7.28|
;;;475      {
;;;476        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;477        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
000008  d004              BEQ      |L7.20|
;;;478        {
;;;479          FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
;;;480        }
;;;481        else
;;;482        {
;;;483          FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
00000a  f8520f80          LDR      r0,[r2,#0x80]!
00000e  f0400004          ORR      r0,r0,#4
000012  e009              B        |L7.40|
                  |L7.20|
000014  6e10              LDR      r0,[r2,#0x60]         ;479
000016  f0400004          ORR      r0,r0,#4              ;479
00001a  e009              B        |L7.48|
                  |L7.28|
;;;484        }
;;;485      }
;;;486      else
;;;487      {
;;;488        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;489        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;490        {
;;;491          FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
00001c  4905              LDR      r1,|L7.52|
00001e  2810              CMP      r0,#0x10              ;489
000020  d004              BEQ      |L7.44|
;;;492        }
;;;493        else
;;;494        {
;;;495          FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
000022  f8520f80          LDR      r0,[r2,#0x80]!
000026  4008              ANDS     r0,r0,r1
                  |L7.40|
000028  6010              STR      r0,[r2,#0]            ;483
;;;496        }
;;;497      }
;;;498    }
00002a  4770              BX       lr
                  |L7.44|
00002c  6e10              LDR      r0,[r2,#0x60]         ;491
00002e  4008              ANDS     r0,r0,r1              ;491
                  |L7.48|
000030  6610              STR      r0,[r2,#0x60]         ;479
000032  4770              BX       lr
;;;499    /**
                          ENDP

                  |L7.52|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_NANDDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDDeInit PROC
;;;343      */
;;;344    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
000000  b510              PUSH     {r4,lr}
;;;345    {
;;;346      /* Check the parameter */
;;;347      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;348      
;;;349      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;350      {
;;;351        /* Set the FSMC_Bank2 registers to their reset values */
;;;352        FSMC_Bank2->PCR2 = 0x00000018;
000002  2418              MOVS     r4,#0x18
;;;353        FSMC_Bank2->SR2 = 0x00000040;
000004  2340              MOVS     r3,#0x40
000006  f04f4120          MOV      r1,#0xa0000000        ;352
;;;354        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
00000a  f04f32fc          MOV      r2,#0xfcfcfcfc
00000e  2810              CMP      r0,#0x10              ;349
000010  d005              BEQ      |L8.30|
;;;355        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
;;;356      }
;;;357      /* FSMC_Bank3_NAND */  
;;;358      else
;;;359      {
;;;360        /* Set the FSMC_Bank3 registers to their reset values */
;;;361        FSMC_Bank3->PCR3 = 0x00000018;
000012  f8414f80          STR      r4,[r1,#0x80]!
;;;362        FSMC_Bank3->SR3 = 0x00000040;
000016  604b              STR      r3,[r1,#4]
;;;363        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
000018  608a              STR      r2,[r1,#8]
;;;364        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
00001a  60ca              STR      r2,[r1,#0xc]
;;;365      }  
;;;366    }
00001c  bd10              POP      {r4,pc}
                  |L8.30|
00001e  660c              STR      r4,[r1,#0x60]         ;352
000020  664b              STR      r3,[r1,#0x64]         ;353
000022  668a              STR      r2,[r1,#0x68]         ;354
000024  66ca              STR      r2,[r1,#0x6c]         ;355
000026  bd10              POP      {r4,pc}
;;;367    
                          ENDP


                          AREA ||i.FSMC_NANDECCCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDECCCmd PROC
;;;508      */
;;;509    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;510    {
;;;511      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;512      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;513      
;;;514      if (NewState != DISABLE)
000004  b151              CBZ      r1,|L9.28|
;;;515      {
;;;516        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;517        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
000008  d004              BEQ      |L9.20|
;;;518        {
;;;519          FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
;;;520        }
;;;521        else
;;;522        {
;;;523          FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
00000a  f8520f80          LDR      r0,[r2,#0x80]!
00000e  f0400040          ORR      r0,r0,#0x40
000012  e009              B        |L9.40|
                  |L9.20|
000014  6e10              LDR      r0,[r2,#0x60]         ;519
000016  f0400040          ORR      r0,r0,#0x40           ;519
00001a  e009              B        |L9.48|
                  |L9.28|
;;;524        }
;;;525      }
;;;526      else
;;;527      {
;;;528        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;529        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;530        {
;;;531          FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
00001c  4905              LDR      r1,|L9.52|
00001e  2810              CMP      r0,#0x10              ;529
000020  d004              BEQ      |L9.44|
;;;532        }
;;;533        else
;;;534        {
;;;535          FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
000022  f8520f80          LDR      r0,[r2,#0x80]!
000026  4008              ANDS     r0,r0,r1
                  |L9.40|
000028  6010              STR      r0,[r2,#0]            ;523
;;;536        }
;;;537      }
;;;538    }
00002a  4770              BX       lr
                  |L9.44|
00002c  6e10              LDR      r0,[r2,#0x60]         ;531
00002e  4008              ANDS     r0,r0,r1              ;531
                  |L9.48|
000030  6610              STR      r0,[r2,#0x60]         ;519
000032  4770              BX       lr
;;;539    
                          ENDP

                  |L9.52|
                          DCD      0x000fffbf

                          AREA ||i.FSMC_NANDInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDInit PROC
;;;374      */
;;;375    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;376    {
000002  e9d01201          LDRD     r1,r2,[r0,#4]
;;;377      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
;;;378        
;;;379      /* Check the parameters */
;;;380      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;381      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;382      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;383      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;384      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;385      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;386      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;387      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;388      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;389      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;390      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;391      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;392      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;393      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;394      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;395      
;;;396      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;397      tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
000006  4311              ORRS     r1,r1,r2
000008  e9d02303          LDRD     r2,r3,[r0,#0xc]
00000c  431a              ORRS     r2,r2,r3
00000e  4311              ORRS     r1,r1,r2
000010  6942              LDR      r2,[r0,#0x14]
000012  ea412142          ORR      r1,r1,r2,LSL #9
000016  6982              LDR      r2,[r0,#0x18]
000018  ea413142          ORR      r1,r1,r2,LSL #13
;;;398                PCR_MEMORYTYPE_NAND |
;;;399                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;400                FSMC_NANDInitStruct->FSMC_ECC |
;;;401                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;402                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;403                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;404                
;;;405      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;406      tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
00001c  69c2              LDR      r2,[r0,#0x1c]
00001e  f0410308          ORR      r3,r1,#8              ;397
000022  e9d21400          LDRD     r1,r4,[r2,#0]
000026  ea412104          ORR      r1,r1,r4,LSL #8
00002a  6894              LDR      r4,[r2,#8]
00002c  68d2              LDR      r2,[r2,#0xc]
00002e  0424              LSLS     r4,r4,#16
000030  ea446202          ORR      r2,r4,r2,LSL #24
000034  4311              ORRS     r1,r1,r2
;;;407                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;408                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;409                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;410                
;;;411      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;412      tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000036  6a02              LDR      r2,[r0,#0x20]
000038  e9d24500          LDRD     r4,r5,[r2,#0]
00003c  ea442c05          ORR      r12,r4,r5,LSL #8
000040  6894              LDR      r4,[r2,#8]
000042  68d2              LDR      r2,[r2,#0xc]
000044  0424              LSLS     r4,r4,#16
000046  ea446202          ORR      r2,r4,r2,LSL #24
00004a  ea4c0c02          ORR      r12,r12,r2
;;;413                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;414                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;415                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;416      
;;;417      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
;;;418      {
;;;419        /* FSMC_Bank2_NAND registers configuration */
;;;420        FSMC_Bank2->PCR2 = tmppcr;
00004e  6802              LDR      r2,[r0,#0]
000050  f04f4020          MOV      r0,#0xa0000000
000054  2a10              CMP      r2,#0x10              ;417
000056  d005              BEQ      |L10.100|
;;;421        FSMC_Bank2->PMEM2 = tmppmem;
;;;422        FSMC_Bank2->PATT2 = tmppatt;
;;;423      }
;;;424      else
;;;425      {
;;;426        /* FSMC_Bank3_NAND registers configuration */
;;;427        FSMC_Bank3->PCR3 = tmppcr;
000058  f8403f80          STR      r3,[r0,#0x80]!
;;;428        FSMC_Bank3->PMEM3 = tmppmem;
00005c  6081              STR      r1,[r0,#8]
;;;429        FSMC_Bank3->PATT3 = tmppatt;
00005e  f8c0c00c          STR      r12,[r0,#0xc]
;;;430      }
;;;431    }
000062  bd30              POP      {r4,r5,pc}
                  |L10.100|
000064  6603              STR      r3,[r0,#0x60]         ;420
000066  6681              STR      r1,[r0,#0x68]         ;421
000068  f8c0c06c          STR      r12,[r0,#0x6c]        ;422
00006c  bd30              POP      {r4,r5,pc}
;;;432    
                          ENDP


                          AREA ||i.FSMC_NANDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDStructInit PROC
;;;439      */
;;;440    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  2110              MOVS     r1,#0x10
;;;441    { 
;;;442      /* Reset NAND Init structure parameters values */
;;;443      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
;;;444      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000002  6001              STR      r1,[r0,#0]
000004  2100              MOVS     r1,#0
;;;445      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000006  6041              STR      r1,[r0,#4]
;;;446      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
000008  6081              STR      r1,[r0,#8]
;;;447      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
00000a  60c1              STR      r1,[r0,#0xc]
;;;448      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
00000c  6101              STR      r1,[r0,#0x10]
;;;449      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
00000e  6141              STR      r1,[r0,#0x14]
;;;450      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000010  6181              STR      r1,[r0,#0x18]
000012  69c2              LDR      r2,[r0,#0x1c]
000014  21fc              MOVS     r1,#0xfc
;;;451      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000016  6011              STR      r1,[r2,#0]
000018  69c2              LDR      r2,[r0,#0x1c]
;;;452      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00001a  6051              STR      r1,[r2,#4]
00001c  69c2              LDR      r2,[r0,#0x1c]
;;;453      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
00001e  6091              STR      r1,[r2,#8]
000020  69c2              LDR      r2,[r0,#0x1c]
;;;454      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000022  60d1              STR      r1,[r2,#0xc]
000024  6a02              LDR      r2,[r0,#0x20]
;;;455      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000026  6011              STR      r1,[r2,#0]
000028  6a02              LDR      r2,[r0,#0x20]
;;;456      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00002a  6051              STR      r1,[r2,#4]
00002c  6a02              LDR      r2,[r0,#0x20]
;;;457      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
00002e  6091              STR      r1,[r2,#8]
000030  6a00              LDR      r0,[r0,#0x20]
000032  60c1              STR      r1,[r0,#0xc]
;;;458    }
000034  4770              BX       lr
;;;459    
                          ENDP


                          AREA ||i.FSMC_NORSRAMCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMCmd PROC
;;;272      */
;;;273    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;274    {
;;;275      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;276      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;277      
;;;278      if (NewState != DISABLE)
;;;279      {
;;;280        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;281        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
000004  eb020080          ADD      r0,r2,r0,LSL #2
000008  2900              CMP      r1,#0                 ;278
;;;282      }
;;;283      else
;;;284      {
;;;285        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;286        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
00000a  6801              LDR      r1,[r0,#0]
00000c  d002              BEQ      |L12.20|
00000e  f0410101          ORR      r1,r1,#1              ;281
000012  e001              B        |L12.24|
                  |L12.20|
000014  4a01              LDR      r2,|L12.28|
000016  4011              ANDS     r1,r1,r2
                  |L12.24|
000018  6001              STR      r1,[r0,#0]            ;281
;;;287      }
;;;288    }
00001a  4770              BX       lr
;;;289    /**
                          ENDP

                  |L12.28|
                          DCD      0x000ffffe

                          AREA ||i.FSMC_NORSRAMDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMDeInit PROC
;;;120      */
;;;121    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  f04f4220          MOV      r2,#0xa0000000
;;;122    {
;;;123      /* Check the parameter */
;;;124      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;125      
;;;126      /* FSMC_Bank1_NORSRAM1 */
;;;127      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;128      {
;;;129        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
;;;130      }
;;;131      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;132      else
;;;133      {   
;;;134        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000004  eb020180          ADD      r1,r2,r0,LSL #2
000008  b140              CBZ      r0,|L13.28|
00000a  f24300d2          MOV      r0,#0x30d2
00000e  6008              STR      r0,[r1,#0]
                  |L13.16|
;;;135      }
;;;136      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
000010  f06f4070          MVN      r0,#0xf0000000
000014  6048              STR      r0,[r1,#4]
;;;137      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
000016  f8c10104          STR      r0,[r1,#0x104]
;;;138    }
00001a  4770              BX       lr
                  |L13.28|
00001c  f24300db          MOV      r0,#0x30db            ;129
000020  6010              STR      r0,[r2,#0]            ;129
000022  e7f5              B        |L13.16|
;;;139    
                          ENDP


                          AREA ||i.FSMC_NORSRAMInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMInit PROC
;;;147      */
;;;148    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;149    { 
000002  e9d01201          LDRD     r1,r2,[r0,#4]
;;;150      /* Check the parameters */
;;;151      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;152      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;153      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;154      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;155      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;156      assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
;;;157      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;158      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;159      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;160      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;161      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;162      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;163      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;164      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;165      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;166      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;167      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;168      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;169      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;170      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;171      
;;;172      /* Bank1 NOR/SRAM control register configuration */ 
;;;173      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
000006  4311              ORRS     r1,r1,r2
000008  e9d02303          LDRD     r2,r3,[r0,#0xc]
00000c  431a              ORRS     r2,r2,r3
00000e  4311              ORRS     r1,r1,r2
000010  6942              LDR      r2,[r0,#0x14]
000012  6803              LDR      r3,[r0,#0]
000014  4311              ORRS     r1,r1,r2
000016  6982              LDR      r2,[r0,#0x18]
000018  4311              ORRS     r1,r1,r2
00001a  69c2              LDR      r2,[r0,#0x1c]
00001c  4311              ORRS     r1,r1,r2
00001e  6a02              LDR      r2,[r0,#0x20]
000020  4311              ORRS     r1,r1,r2
000022  6a42              LDR      r2,[r0,#0x24]
000024  4311              ORRS     r1,r1,r2
000026  6a82              LDR      r2,[r0,#0x28]
000028  4311              ORRS     r1,r1,r2
00002a  6ac2              LDR      r2,[r0,#0x2c]
00002c  4311              ORRS     r1,r1,r2
00002e  6b02              LDR      r2,[r0,#0x30]
000030  4311              ORRS     r1,r1,r2
000032  f04f4220          MOV      r2,#0xa0000000
000036  f8421023          STR      r1,[r2,r3,LSL #2]
;;;174                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;175                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;176                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;177                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;178                FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
;;;179                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;180                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;181                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;182                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;183                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;184                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;185                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;186      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
00003a  6881              LDR      r1,[r0,#8]
00003c  2908              CMP      r1,#8
00003e  d106              BNE      |L14.78|
;;;187      {
;;;188        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
000040  6801              LDR      r1,[r0,#0]
000042  eb020181          ADD      r1,r2,r1,LSL #2
000046  680b              LDR      r3,[r1,#0]
000048  f0430340          ORR      r3,r3,#0x40
00004c  600b              STR      r3,[r1,#0]
                  |L14.78|
;;;189      }
;;;190      /* Bank1 NOR/SRAM timing register configuration */
;;;191      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
00004e  6b41              LDR      r1,[r0,#0x34]
000050  e9d13400          LDRD     r3,r4,[r1,#0]
000054  ea431304          ORR      r3,r3,r4,LSL #4
000058  688c              LDR      r4,[r1,#8]
00005a  68cd              LDR      r5,[r1,#0xc]
00005c  0224              LSLS     r4,r4,#8
00005e  ea444405          ORR      r4,r4,r5,LSL #16
000062  4323              ORRS     r3,r3,r4
000064  690c              LDR      r4,[r1,#0x10]
000066  ea435304          ORR      r3,r3,r4,LSL #20
00006a  694c              LDR      r4,[r1,#0x14]
00006c  6989              LDR      r1,[r1,#0x18]
00006e  ea436304          ORR      r3,r3,r4,LSL #24
000072  430b              ORRS     r3,r3,r1
000074  6801              LDR      r1,[r0,#0]
000076  eb020181          ADD      r1,r2,r1,LSL #2
00007a  604b              STR      r3,[r1,#4]
;;;192                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;193                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;194                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;195                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;196                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;197                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;198                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;199                
;;;200        
;;;201      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;202      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
00007c  6ac1              LDR      r1,[r0,#0x2c]
00007e  f5b14f80          CMP      r1,#0x4000
000082  d007              BEQ      |L14.148|
;;;203      {
;;;204        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;205        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;206        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;207        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;208        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;209        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;210        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
;;;211                  (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;212                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;213                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;214                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;215                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;216                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;217      }
;;;218      else
;;;219      {
;;;220        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
000084  6800              LDR      r0,[r0,#0]
000086  f06f4170          MVN      r1,#0xf0000000
00008a  eb020080          ADD      r0,r2,r0,LSL #2
00008e  f8c01104          STR      r1,[r0,#0x104]
;;;221      }
;;;222    }
000092  bd30              POP      {r4,r5,pc}
                  |L14.148|
000094  6b81              LDR      r1,[r0,#0x38]         ;210
000096  6800              LDR      r0,[r0,#0]            ;210
000098  e9d13400          LDRD     r3,r4,[r1,#0]         ;210
00009c  ea431304          ORR      r3,r3,r4,LSL #4       ;210
0000a0  688c              LDR      r4,[r1,#8]            ;210
0000a2  690d              LDR      r5,[r1,#0x10]         ;210
0000a4  0224              LSLS     r4,r4,#8              ;210
0000a6  ea445405          ORR      r4,r4,r5,LSL #20      ;210
0000aa  4323              ORRS     r3,r3,r4              ;210
0000ac  694c              LDR      r4,[r1,#0x14]         ;210
0000ae  6989              LDR      r1,[r1,#0x18]         ;210
0000b0  ea436304          ORR      r3,r3,r4,LSL #24      ;210
0000b4  eb020080          ADD      r0,r2,r0,LSL #2       ;210
0000b8  430b              ORRS     r3,r3,r1              ;210
0000ba  f8c03104          STR      r3,[r0,#0x104]        ;210
0000be  bd30              POP      {r4,r5,pc}
;;;223    
                          ENDP


                          AREA ||i.FSMC_NORSRAMStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMStructInit PROC
;;;229      */
;;;230    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  b510              PUSH     {r4,lr}
;;;231    {  
;;;232      /* Reset NOR/SRAM Init structure parameters values */
;;;233      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
000002  2100              MOVS     r1,#0
;;;234      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
000004  2202              MOVS     r2,#2
000006  e9c01200          STRD     r1,r2,[r0,#0]
;;;235      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;236      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
00000a  6081              STR      r1,[r0,#8]
;;;237      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00000c  60c1              STR      r1,[r0,#0xc]
;;;238      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
00000e  6101              STR      r1,[r0,#0x10]
;;;239      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000010  6141              STR      r1,[r0,#0x14]
;;;240      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000012  6181              STR      r1,[r0,#0x18]
;;;241      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;242      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000014  02d2              LSLS     r2,r2,#11
000016  61c1              STR      r1,[r0,#0x1c]
000018  e9c01208          STRD     r1,r2,[r0,#0x20]
;;;243      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
00001c  0052              LSLS     r2,r2,#1
00001e  e9c0210a          STRD     r2,r1,[r0,#0x28]
;;;244      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
;;;245      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
;;;246      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000022  6301              STR      r1,[r0,#0x30]
000024  6b43              LDR      r3,[r0,#0x34]
000026  220f              MOVS     r2,#0xf
;;;247      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000028  601a              STR      r2,[r3,#0]
00002a  6b43              LDR      r3,[r0,#0x34]
;;;248      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
00002c  605a              STR      r2,[r3,#4]
00002e  6b44              LDR      r4,[r0,#0x34]
000030  23ff              MOVS     r3,#0xff
;;;249      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
000032  60a3              STR      r3,[r4,#8]
000034  6b44              LDR      r4,[r0,#0x34]
;;;250      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
000036  60e2              STR      r2,[r4,#0xc]
000038  6b44              LDR      r4,[r0,#0x34]
;;;251      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
00003a  6122              STR      r2,[r4,#0x10]
00003c  6b44              LDR      r4,[r0,#0x34]
;;;252      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
00003e  6162              STR      r2,[r4,#0x14]
000040  6b44              LDR      r4,[r0,#0x34]
;;;253      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000042  61a1              STR      r1,[r4,#0x18]
000044  6b84              LDR      r4,[r0,#0x38]
;;;254      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000046  6022              STR      r2,[r4,#0]
000048  6b84              LDR      r4,[r0,#0x38]
;;;255      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
00004a  6062              STR      r2,[r4,#4]
00004c  6b84              LDR      r4,[r0,#0x38]
;;;256      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
00004e  60a3              STR      r3,[r4,#8]
000050  6b83              LDR      r3,[r0,#0x38]
;;;257      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
000052  60da              STR      r2,[r3,#0xc]
000054  6b83              LDR      r3,[r0,#0x38]
;;;258      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
000056  611a              STR      r2,[r3,#0x10]
000058  6b83              LDR      r3,[r0,#0x38]
;;;259      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
00005a  615a              STR      r2,[r3,#0x14]
00005c  6b80              LDR      r0,[r0,#0x38]
00005e  6181              STR      r1,[r0,#0x18]
;;;260    }
000060  bd10              POP      {r4,pc}
;;;261    
                          ENDP


                          AREA ||i.FSMC_PCCARDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDCmd PROC
;;;706      */
;;;707    void FSMC_PCCARDCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L16.24|
;;;708    {
;;;709      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;710      
;;;711      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;712      {
;;;713        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;714        FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
;;;715      }
;;;716      else
;;;717      {
;;;718        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;719        FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L16.14|
000008  f0400004          ORR      r0,r0,#4              ;714
00000c  e001              B        |L16.18|
                  |L16.14|
00000e  4a03              LDR      r2,|L16.28|
000010  4010              ANDS     r0,r0,r2
                  |L16.18|
000012  6008              STR      r0,[r1,#0]            ;714
;;;720      }
;;;721    }
000014  4770              BX       lr
;;;722    /**
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      0xa00000a0
                  |L16.28|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_PCCARDDeInit||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDDeInit PROC
;;;611      */
;;;612    void FSMC_PCCARDDeInit(void)
000000  4805              LDR      r0,|L17.24|
;;;613    {
;;;614      /* Set the FSMC_Bank4 registers to their reset values */
;;;615      FSMC_Bank4->PCR4 = 0x00000018; 
000002  2118              MOVS     r1,#0x18
000004  6001              STR      r1,[r0,#0]
;;;616      FSMC_Bank4->SR4 = 0x00000000;	
000006  f04f0100          MOV      r1,#0
00000a  6041              STR      r1,[r0,#4]
;;;617      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
00000c  f04f31fc          MOV      r1,#0xfcfcfcfc
000010  6081              STR      r1,[r0,#8]
;;;618      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
000012  60c1              STR      r1,[r0,#0xc]
;;;619      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
000014  6101              STR      r1,[r0,#0x10]
;;;620    }
000016  4770              BX       lr
;;;621    
                          ENDP

                  |L17.24|
                          DCD      0xa00000a0

                          AREA ||i.FSMC_PCCARDInit||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDInit PROC
;;;628      */
;;;629    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  b510              PUSH     {r4,lr}
;;;630    {
000002  e9d01200          LDRD     r1,r2,[r0,#0]
;;;631      /* Check the parameters */
;;;632      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;633      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;634      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;635     
;;;636      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;637      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;638      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;639      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;640      
;;;641      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;642      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;643      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;644      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;645      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;646      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;647      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;648      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;649      
;;;650      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;651      FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
000006  ea412242          ORR      r2,r1,r2,LSL #9
00000a  6881              LDR      r1,[r0,#8]
00000c  2310              MOVS     r3,#0x10
00000e  ea433141          ORR      r1,r3,r1,LSL #13
000012  430a              ORRS     r2,r2,r1
000014  4916              LDR      r1,|L18.112|
000016  600a              STR      r2,[r1,#0]
;;;652                         FSMC_MemoryDataWidth_16b |  
;;;653                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;654                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;655                
;;;656      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;657      FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000018  68c2              LDR      r2,[r0,#0xc]
00001a  e9d23400          LDRD     r3,r4,[r2,#0]
00001e  ea432304          ORR      r3,r3,r4,LSL #8
000022  6894              LDR      r4,[r2,#8]
000024  68d2              LDR      r2,[r2,#0xc]
000026  ea4f4404          LSL      r4,r4,#16
00002a  ea446202          ORR      r2,r4,r2,LSL #24
00002e  ea430302          ORR      r3,r3,r2
000032  608b              STR      r3,[r1,#8]
;;;658                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;659                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;660                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;661                
;;;662      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;663      FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000034  6902              LDR      r2,[r0,#0x10]
000036  e9d23400          LDRD     r3,r4,[r2,#0]
00003a  ea432304          ORR      r3,r3,r4,LSL #8
00003e  6894              LDR      r4,[r2,#8]
000040  68d2              LDR      r2,[r2,#0xc]
000042  ea4f4404          LSL      r4,r4,#16
000046  ea446202          ORR      r2,r4,r2,LSL #24
00004a  ea430302          ORR      r3,r3,r2
00004e  60cb              STR      r3,[r1,#0xc]
;;;664                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;665                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;666                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;667                
;;;668      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;669      FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
000050  6940              LDR      r0,[r0,#0x14]
000052  e9d02300          LDRD     r2,r3,[r0,#0]
000056  ea422203          ORR      r2,r2,r3,LSL #8
00005a  6883              LDR      r3,[r0,#8]
00005c  68c0              LDR      r0,[r0,#0xc]
00005e  ea4f4303          LSL      r3,r3,#16
000062  ea436000          ORR      r0,r3,r0,LSL #24
000066  ea420200          ORR      r2,r2,r0
00006a  610a              STR      r2,[r1,#0x10]
;;;670                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;671                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;672                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;673    }
00006c  bd10              POP      {r4,pc}
;;;674    
                          ENDP

00006e  0000              DCW      0x0000
                  |L18.112|
                          DCD      0xa00000a0

                          AREA ||i.FSMC_PCCARDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDStructInit PROC
;;;680      */
;;;681    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  2100              MOVS     r1,#0
;;;682    {
;;;683      /* Reset PCCARD Init structure parameters values */
;;;684      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
;;;685      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000002  6001              STR      r1,[r0,#0]
;;;686      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
000004  6041              STR      r1,[r0,#4]
;;;687      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000006  6081              STR      r1,[r0,#8]
000008  68c2              LDR      r2,[r0,#0xc]
00000a  21fc              MOVS     r1,#0xfc
;;;688      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00000c  6011              STR      r1,[r2,#0]
00000e  68c2              LDR      r2,[r0,#0xc]
;;;689      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000010  6051              STR      r1,[r2,#4]
000012  68c2              LDR      r2,[r0,#0xc]
;;;690      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000014  6091              STR      r1,[r2,#8]
000016  68c2              LDR      r2,[r0,#0xc]
;;;691      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000018  60d1              STR      r1,[r2,#0xc]
00001a  6902              LDR      r2,[r0,#0x10]
;;;692      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00001c  6011              STR      r1,[r2,#0]
00001e  6902              LDR      r2,[r0,#0x10]
;;;693      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000020  6051              STR      r1,[r2,#4]
000022  6902              LDR      r2,[r0,#0x10]
;;;694      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000024  6091              STR      r1,[r2,#8]
000026  6902              LDR      r2,[r0,#0x10]
;;;695      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000028  60d1              STR      r1,[r2,#0xc]
00002a  6942              LDR      r2,[r0,#0x14]
;;;696      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00002c  6011              STR      r1,[r2,#0]
00002e  6942              LDR      r2,[r0,#0x14]
;;;697      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000030  6051              STR      r1,[r2,#4]
000032  6942              LDR      r2,[r0,#0x14]
;;;698      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000034  6091              STR      r1,[r2,#8]
000036  6940              LDR      r0,[r0,#0x14]
000038  60c1              STR      r1,[r0,#0xc]
;;;699    }
00003a  4770              BX       lr
;;;700    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_fsmc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_2e710976____REV16|
#line 114 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f4xx_fsmc_c_2e710976____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_2e710976____REVSH|
#line 128
|__asm___16_stm32f4xx_fsmc_c_2e710976____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
