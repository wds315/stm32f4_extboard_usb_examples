; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\STM324xG-EVAL\stm32f4xx_flash.o --asm_dir=.\STM324xG-EVAL\ --list_dir=.\STM324xG-EVAL\ --depend=.\STM324xG-EVAL\stm32f4xx_flash.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -I..\ -I..\inc -I..\..\..\..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\..\..\Utilities\STM32_EVAL -I..\..\..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\..\..\Utilities\STM32_EVAL\STM3240_41_G_EVAL -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F4XX -DUSE_STM324xG_EVAL --omf_browse=.\STM324xG-EVAL\stm32f4xx_flash.crf ..\..\..\..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;969      */
;;;970    void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;971    {
;;;972      /* Check the parameters */
;;;973      assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
;;;974      
;;;975      /* Clear the flags */
;;;976      FLASH->SR = FLASH_FLAG;
000002  6008              STR      r0,[r1,#0]
;;;977    }
000004  4770              BX       lr
;;;978    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_DataCacheCmd||, CODE, READONLY, ALIGN=2

                  FLASH_DataCacheCmd PROC
;;;229      */
;;;230    void FLASH_DataCacheCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L2.24|
;;;231    {
;;;232      /* Check the parameters */
;;;233      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;234      
;;;235      if(NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;236      {
;;;237        FLASH->ACR |= FLASH_ACR_DCEN;
;;;238      }
;;;239      else
;;;240      {
;;;241        FLASH->ACR &= (~FLASH_ACR_DCEN);
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L2.14|
000008  f4406080          ORR      r0,r0,#0x400          ;237
00000c  e001              B        |L2.18|
                  |L2.14|
00000e  f4206080          BIC      r0,r0,#0x400
                  |L2.18|
000012  6008              STR      r0,[r1,#0]            ;237
;;;242      }
;;;243    }
000014  4770              BX       lr
;;;244    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      0x40023c00

                          AREA ||i.FLASH_DataCacheReset||, CODE, READONLY, ALIGN=2

                  FLASH_DataCacheReset PROC
;;;261      */
;;;262    void FLASH_DataCacheReset(void)
000000  4802              LDR      r0,|L3.12|
;;;263    {
;;;264      FLASH->ACR |= FLASH_ACR_DCRST;
000002  6801              LDR      r1,[r0,#0]
000004  f4415180          ORR      r1,r1,#0x1000
000008  6001              STR      r1,[r0,#0]
;;;265    }
00000a  4770              BX       lr
;;;266    
                          ENDP

                  |L3.12|
                          DCD      0x40023c00

                          AREA ||i.FLASH_EraseAllSectors||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllSectors PROC
;;;411      */
;;;412    FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
000000  b510              PUSH     {r4,lr}
;;;413    {
000002  4603              MOV      r3,r0
;;;414      uint32_t tmp_psize = 0x0;
000004  2400              MOVS     r4,#0
;;;415      FLASH_Status status = FLASH_COMPLETE;
;;;416      
;;;417      /* Wait for last operation to be completed */
;;;418      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;419      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;420      
;;;421      if(VoltageRange == VoltageRange_1)
00000a  b12b              CBZ      r3,|L4.24|
;;;422      {
;;;423         tmp_psize = FLASH_PSIZE_BYTE;
;;;424      }
;;;425      else if(VoltageRange == VoltageRange_2)
00000c  2b01              CMP      r3,#1
00000e  d01c              BEQ      |L4.74|
;;;426      {
;;;427        tmp_psize = FLASH_PSIZE_HALF_WORD;
;;;428      }
;;;429      else if(VoltageRange == VoltageRange_3)
000010  2b02              CMP      r3,#2
000012  d01d              BEQ      |L4.80|
;;;430      {
;;;431        tmp_psize = FLASH_PSIZE_WORD;
;;;432      }
;;;433      else
;;;434      {
;;;435        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
000014  f44f7440          MOV      r4,#0x300
                  |L4.24|
;;;436      }  
;;;437      if(status == FLASH_COMPLETE)
000018  2808              CMP      r0,#8
00001a  d115              BNE      |L4.72|
;;;438      {
;;;439        /* if the previous operation is completed, proceed to erase all sectors */
;;;440         FLASH->CR &= CR_PSIZE_MASK;
00001c  4b0e              LDR      r3,|L4.88|
00001e  6818              LDR      r0,[r3,#0]
000020  f4207040          BIC      r0,r0,#0x300
000024  6018              STR      r0,[r3,#0]
;;;441         FLASH->CR |= tmp_psize;
000026  6818              LDR      r0,[r3,#0]
000028  4320              ORRS     r0,r0,r4
00002a  6018              STR      r0,[r3,#0]
;;;442         FLASH->CR |= FLASH_CR_MER;
00002c  6818              LDR      r0,[r3,#0]
00002e  f0400004          ORR      r0,r0,#4
000032  6018              STR      r0,[r3,#0]
;;;443         FLASH->CR |= FLASH_CR_STRT;
000034  6818              LDR      r0,[r3,#0]
000036  f4403080          ORR      r0,r0,#0x10000
00003a  6018              STR      r0,[r3,#0]
;;;444        
;;;445        /* Wait for last operation to be completed */
;;;446        status = FLASH_WaitForLastOperation();
00003c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;447    
;;;448        /* if the erase operation is completed, disable the MER Bit */
;;;449        FLASH->CR &= (~FLASH_CR_MER);
000040  6819              LDR      r1,[r3,#0]
000042  f0210104          BIC      r1,r1,#4
000046  6019              STR      r1,[r3,#0]
                  |L4.72|
;;;450    
;;;451      }   
;;;452      /* Return the Erase Status */
;;;453      return status;
;;;454    }
000048  bd10              POP      {r4,pc}
                  |L4.74|
00004a  f44f7480          MOV      r4,#0x100             ;427
00004e  e7e3              B        |L4.24|
                  |L4.80|
000050  f44f7400          MOV      r4,#0x200             ;431
000054  e7e0              B        |L4.24|
;;;455    
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
                          DCD      0x40023c10

                          AREA ||i.FLASH_EraseSector||, CODE, READONLY, ALIGN=2

                  FLASH_EraseSector PROC
;;;346      */
;;;347    FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
000000  b530              PUSH     {r4,r5,lr}
;;;348    {
000002  4605              MOV      r5,r0
;;;349      uint32_t tmp_psize = 0x0;
000004  2400              MOVS     r4,#0
;;;350      FLASH_Status status = FLASH_COMPLETE;
;;;351    
;;;352      /* Check the parameters */
;;;353      assert_param(IS_FLASH_SECTOR(FLASH_Sector));
;;;354      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;355      
;;;356      if(VoltageRange == VoltageRange_1)
000006  b129              CBZ      r1,|L5.20|
;;;357      {
;;;358         tmp_psize = FLASH_PSIZE_BYTE;
;;;359      }
;;;360      else if(VoltageRange == VoltageRange_2)
000008  2901              CMP      r1,#1
00000a  d027              BEQ      |L5.92|
;;;361      {
;;;362        tmp_psize = FLASH_PSIZE_HALF_WORD;
;;;363      }
;;;364      else if(VoltageRange == VoltageRange_3)
00000c  2902              CMP      r1,#2
00000e  d028              BEQ      |L5.98|
;;;365      {
;;;366        tmp_psize = FLASH_PSIZE_WORD;
;;;367      }
;;;368      else
;;;369      {
;;;370        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
000010  f44f7440          MOV      r4,#0x300
                  |L5.20|
;;;371      }
;;;372      /* Wait for last operation to be completed */
;;;373      status = FLASH_WaitForLastOperation();
000014  f7fffffe          BL       FLASH_WaitForLastOperation
;;;374      
;;;375      if(status == FLASH_COMPLETE)
000018  2808              CMP      r0,#8
00001a  d11e              BNE      |L5.90|
;;;376      { 
;;;377        /* if the previous operation is completed, proceed to erase the sector */
;;;378        FLASH->CR &= CR_PSIZE_MASK;
00001c  4b12              LDR      r3,|L5.104|
00001e  6818              LDR      r0,[r3,#0]
000020  f4207040          BIC      r0,r0,#0x300
000024  6018              STR      r0,[r3,#0]
;;;379        FLASH->CR |= tmp_psize;
000026  6818              LDR      r0,[r3,#0]
000028  4320              ORRS     r0,r0,r4
00002a  6018              STR      r0,[r3,#0]
;;;380        FLASH->CR &= SECTOR_MASK;
00002c  6818              LDR      r0,[r3,#0]
00002e  f02000f8          BIC      r0,r0,#0xf8
000032  6018              STR      r0,[r3,#0]
;;;381        FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
000034  6818              LDR      r0,[r3,#0]
000036  f0450102          ORR      r1,r5,#2
00003a  4308              ORRS     r0,r0,r1
00003c  6018              STR      r0,[r3,#0]
;;;382        FLASH->CR |= FLASH_CR_STRT;
00003e  6818              LDR      r0,[r3,#0]
000040  f4403080          ORR      r0,r0,#0x10000
000044  6018              STR      r0,[r3,#0]
;;;383        
;;;384        /* Wait for last operation to be completed */
;;;385        status = FLASH_WaitForLastOperation();
000046  f7fffffe          BL       FLASH_WaitForLastOperation
;;;386        
;;;387        /* if the erase operation is completed, disable the SER Bit */
;;;388        FLASH->CR &= (~FLASH_CR_SER);
00004a  6819              LDR      r1,[r3,#0]
00004c  f0210102          BIC      r1,r1,#2
000050  6019              STR      r1,[r3,#0]
;;;389        FLASH->CR &= SECTOR_MASK; 
000052  6819              LDR      r1,[r3,#0]
000054  f02101f8          BIC      r1,r1,#0xf8
000058  6019              STR      r1,[r3,#0]
                  |L5.90|
;;;390      }
;;;391      /* Return the Erase Status */
;;;392      return status;
;;;393    }
00005a  bd30              POP      {r4,r5,pc}
                  |L5.92|
00005c  f44f7480          MOV      r4,#0x100             ;362
000060  e7d8              B        |L5.20|
                  |L5.98|
000062  f44f7400          MOV      r4,#0x200             ;366
000066  e7d5              B        |L5.20|
;;;394    
                          ENDP

                  |L5.104|
                          DCD      0x40023c10

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;939      */
;;;940    FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  4a03              LDR      r2,|L6.16|
;;;941    {
000002  4601              MOV      r1,r0
;;;942      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;943      /* Check the parameters */
;;;944      assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
;;;945    
;;;946      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
000006  6812              LDR      r2,[r2,#0]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L6.14|
;;;947      {
;;;948        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L6.14|
;;;949      }
;;;950      else
;;;951      {
;;;952        bitstatus = RESET;
;;;953      }
;;;954      /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;955      return bitstatus; 
;;;956    }
00000e  4770              BX       lr
;;;957    
                          ENDP

                  |L6.16|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;984      */
;;;985    FLASH_Status FLASH_GetStatus(void)
000000  490b              LDR      r1,|L7.48|
;;;986    {
;;;987      FLASH_Status flashstatus = FLASH_COMPLETE;
000002  2008              MOVS     r0,#8
;;;988      
;;;989      if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000004  680a              LDR      r2,[r1,#0]
000006  03d2              LSLS     r2,r2,#15
000008  d501              BPL      |L7.14|
;;;990      {
;;;991        flashstatus = FLASH_BUSY;
00000a  2001              MOVS     r0,#1
;;;992      }
;;;993      else 
;;;994      {  
;;;995        if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
;;;996        { 
;;;997          flashstatus = FLASH_ERROR_WRP;
;;;998        }
;;;999        else 
;;;1000       {
;;;1001         if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
;;;1002         {
;;;1003           flashstatus = FLASH_ERROR_PROGRAM; 
;;;1004         }
;;;1005         else
;;;1006         {
;;;1007           if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
;;;1008           {
;;;1009             flashstatus = FLASH_ERROR_OPERATION;
;;;1010           }
;;;1011           else
;;;1012           {
;;;1013             flashstatus = FLASH_COMPLETE;
;;;1014           }
;;;1015         }
;;;1016       }
;;;1017     }
;;;1018     /* Return the FLASH Status */
;;;1019     return flashstatus;
;;;1020   }
00000c  4770              BX       lr
                  |L7.14|
00000e  680a              LDR      r2,[r1,#0]            ;995
000010  06d2              LSLS     r2,r2,#27             ;995
000012  d501              BPL      |L7.24|
000014  2005              MOVS     r0,#5                 ;997
000016  4770              BX       lr
                  |L7.24|
000018  680a              LDR      r2,[r1,#0]            ;1001
00001a  f0120fef          TST      r2,#0xef              ;1001
00001e  d001              BEQ      |L7.36|
000020  2006              MOVS     r0,#6                 ;1003
                  |L7.34|
000022  4770              BX       lr
                  |L7.36|
000024  6809              LDR      r1,[r1,#0]            ;1007
000026  0789              LSLS     r1,r1,#30             ;1007
000028  d5fb              BPL      |L7.34|
00002a  2007              MOVS     r0,#7                 ;1009
00002c  4770              BX       lr
;;;1021   
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;908      */
;;;909    void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L8.20|
;;;910    {
;;;911      /* Check the parameters */
;;;912      assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;913      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;914    
;;;915      if(NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;916      {
;;;917        /* Enable the interrupt sources */
;;;918        FLASH->CR |= FLASH_IT;
;;;919      }
;;;920      else
;;;921      {
;;;922        /* Disable the interrupt sources */
;;;923        FLASH->CR &= ~(uint32_t)FLASH_IT;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L8.12|
000008  4301              ORRS     r1,r1,r0              ;918
00000a  e000              B        |L8.14|
                  |L8.12|
00000c  4381              BICS     r1,r1,r0
                  |L8.14|
00000e  6011              STR      r1,[r2,#0]            ;918
;;;924      }
;;;925    }
000010  4770              BX       lr
;;;926    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40023c10

                          AREA ||i.FLASH_InstructionCacheCmd||, CODE, READONLY, ALIGN=2

                  FLASH_InstructionCacheCmd PROC
;;;208      */
;;;209    void FLASH_InstructionCacheCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L9.24|
;;;210    {
;;;211      /* Check the parameters */
;;;212      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;213      
;;;214      if(NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;215      {
;;;216        FLASH->ACR |= FLASH_ACR_ICEN;
;;;217      }
;;;218      else
;;;219      {
;;;220        FLASH->ACR &= (~FLASH_ACR_ICEN);
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L9.14|
000008  f4407000          ORR      r0,r0,#0x200          ;216
00000c  e001              B        |L9.18|
                  |L9.14|
00000e  f4207000          BIC      r0,r0,#0x200
                  |L9.18|
000012  6008              STR      r0,[r1,#0]            ;216
;;;221      }
;;;222    }
000014  4770              BX       lr
;;;223    
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      0x40023c00

                          AREA ||i.FLASH_InstructionCacheReset||, CODE, READONLY, ALIGN=2

                  FLASH_InstructionCacheReset PROC
;;;250      */
;;;251    void FLASH_InstructionCacheReset(void)
000000  4802              LDR      r0,|L10.12|
;;;252    {
;;;253      FLASH->ACR |= FLASH_ACR_ICRST;
000002  6801              LDR      r1,[r0,#0]
000004  f4416100          ORR      r1,r1,#0x800
000008  6001              STR      r1,[r0,#0]
;;;254    }
00000a  4770              BX       lr
;;;255    
                          ENDP

                  |L10.12|
                          DCD      0x40023c00

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;320      */
;;;321    void FLASH_Lock(void)
000000  4802              LDR      r0,|L11.12|
;;;322    {
;;;323      /* Set the LOCK Bit to lock the FLASH Registers access */
;;;324      FLASH->CR |= FLASH_CR_LOCK;
000002  6801              LDR      r1,[r0,#0]
000004  f0414100          ORR      r1,r1,#0x80000000
000008  6001              STR      r1,[r0,#0]
;;;325    }
00000a  4770              BX       lr
;;;326    
                          ENDP

                  |L11.12|
                          DCD      0x40023c10

                          AREA ||i.FLASH_OB_BORConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_BORConfig PROC
;;;794      */
;;;795    void FLASH_OB_BORConfig(uint8_t OB_BOR)
000000  4904              LDR      r1,|L12.20|
;;;796    {
;;;797      /* Check the parameters */
;;;798      assert_param(IS_OB_BOR(OB_BOR));
;;;799    
;;;800      /* Set the BOR Level */
;;;801      *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
000002  780a              LDRB     r2,[r1,#0]
000004  f022020c          BIC      r2,r2,#0xc
000008  700a              STRB     r2,[r1,#0]
;;;802      *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
00000a  780a              LDRB     r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  700a              STRB     r2,[r1,#0]
;;;803    
;;;804    }
000010  4770              BX       lr
;;;805    
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetBOR||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetBOR PROC
;;;878      */
;;;879    uint8_t FLASH_OB_GetBOR(void)
000000  4802              LDR      r0,|L13.12|
;;;880    {
;;;881      /* Return the FLASH BOR level */
;;;882      return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
000002  7800              LDRB     r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;883    }
000008  4770              BX       lr
;;;884    
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetRDP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetRDP PROC
;;;854      */
;;;855    FlagStatus FLASH_OB_GetRDP(void)
000000  4903              LDR      r1,|L14.16|
;;;856    {
;;;857      FlagStatus readstatus = RESET;
000002  2000              MOVS     r0,#0
;;;858    
;;;859      if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
000004  7809              LDRB     r1,[r1,#0]
000006  29aa              CMP      r1,#0xaa
000008  d000              BEQ      |L14.12|
;;;860      {
;;;861        readstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L14.12|
;;;862      }
;;;863      else
;;;864      {
;;;865        readstatus = RESET;
;;;866      }
;;;867      return readstatus;
;;;868    }
00000c  4770              BX       lr
;;;869    
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_GetUser||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetUser PROC
;;;830      */
;;;831    uint8_t FLASH_OB_GetUser(void)
000000  4802              LDR      r0,|L15.12|
;;;832    {
;;;833      /* Return the User Option Byte */
;;;834      return (uint8_t)(FLASH->OPTCR >> 5);
000002  6800              LDR      r0,[r0,#0]
000004  f3c01047          UBFX     r0,r0,#5,#8
;;;835    }
000008  4770              BX       lr
;;;836    
                          ENDP

00000a  0000              DCW      0x0000
                  |L15.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP PROC
;;;841      */
;;;842    uint16_t FLASH_OB_GetWRP(void)
000000  4801              LDR      r0,|L16.8|
;;;843    {
;;;844      /* Return the FLASH write protection Register value */
;;;845      return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;846    }
000004  4770              BX       lr
;;;847    
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_Launch||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Launch PROC
;;;811      */
;;;812    FLASH_Status FLASH_OB_Launch(void)
000000  4803              LDR      r0,|L17.16|
;;;813    {
;;;814      FLASH_Status status = FLASH_COMPLETE;
;;;815    
;;;816      /* Set the OPTSTRT bit in OPTCR register */
;;;817      *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
000002  7801              LDRB     r1,[r0,#0]
000004  f0410102          ORR      r1,r1,#2
000008  7001              STRB     r1,[r0,#0]
;;;818    
;;;819      /* Wait for last operation to be completed */
;;;820      status = FLASH_WaitForLastOperation();
00000a  f7ffbffe          B.W      FLASH_WaitForLastOperation
;;;821    
;;;822      return status;
;;;823    }
;;;824    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Lock PROC
;;;678      */
;;;679    void FLASH_OB_Lock(void)
000000  4802              LDR      r0,|L18.12|
;;;680    {
;;;681      /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
;;;682      FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;683    }
00000a  4770              BX       lr
;;;684    
                          ENDP

                  |L18.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_RDPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_RDPConfig PROC
;;;729      */
;;;730    void FLASH_OB_RDPConfig(uint8_t OB_RDP)
000000  b500              PUSH     {lr}
;;;731    {
000002  4603              MOV      r3,r0
;;;732      FLASH_Status status = FLASH_COMPLETE;
;;;733    
;;;734      /* Check the parameters */
;;;735      assert_param(IS_OB_RDP(OB_RDP));
;;;736    
;;;737      status = FLASH_WaitForLastOperation();
000004  f7fffffe          BL       FLASH_WaitForLastOperation
;;;738    
;;;739      if(status == FLASH_COMPLETE)
000008  2808              CMP      r0,#8
00000a  d101              BNE      |L19.16|
;;;740      {
;;;741        *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
00000c  4801              LDR      r0,|L19.20|
00000e  7003              STRB     r3,[r0,#0]
                  |L19.16|
;;;742    
;;;743      }
;;;744    }
000010  bd00              POP      {pc}
;;;745    
                          ENDP

000012  0000              DCW      0x0000
                  |L19.20|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Unlock PROC
;;;663      */
;;;664    void FLASH_OB_Unlock(void)
000000  4805              LDR      r0,|L20.24|
;;;665    {
;;;666      if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  d005              BEQ      |L20.20|
;;;667      {
;;;668        /* Authorizes the Option Byte register programming */
;;;669        FLASH->OPTKEYR = FLASH_OPT_KEY1;
000008  4803              LDR      r0,|L20.24|
00000a  4904              LDR      r1,|L20.28|
00000c  380c              SUBS     r0,r0,#0xc
00000e  6001              STR      r1,[r0,#0]
;;;670        FLASH->OPTKEYR = FLASH_OPT_KEY2;
000010  4903              LDR      r1,|L20.32|
000012  6001              STR      r1,[r0,#0]
                  |L20.20|
;;;671      }  
;;;672    }
000014  4770              BX       lr
;;;673    
                          ENDP

000016  0000              DCW      0x0000
                  |L20.24|
                          DCD      0x40023c14
                  |L20.28|
                          DCD      0x08192a3b
                  |L20.32|
                          DCD      0x4c5d6e7f

                          AREA ||i.FLASH_OB_UserConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_UserConfig PROC
;;;761      */
;;;762    void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
000000  b530              PUSH     {r4,r5,lr}
;;;763    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
000006  4615              MOV      r5,r2
;;;764      uint8_t optiontmp = 0xFF;
;;;765      FLASH_Status status = FLASH_COMPLETE; 
;;;766    
;;;767      /* Check the parameters */
;;;768      assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;769      assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;770      assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;771    
;;;772      /* Wait for last operation to be completed */
;;;773      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;774      
;;;775      if(status == FLASH_COMPLETE)
00000c  2808              CMP      r0,#8
00000e  d107              BNE      |L21.32|
;;;776      { 
;;;777        /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
;;;778        optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
000010  4904              LDR      r1,|L21.36|
000012  7808              LDRB     r0,[r1,#0]
000014  f000000f          AND      r0,r0,#0xf
;;;779    
;;;780        /* Update User Option Byte */
;;;781        *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
000018  4303              ORRS     r3,r3,r0
00001a  432b              ORRS     r3,r3,r5
00001c  4323              ORRS     r3,r3,r4
00001e  700b              STRB     r3,[r1,#0]
                  |L21.32|
;;;782      }  
;;;783    }
000020  bd30              POP      {r4,r5,pc}
;;;784    
                          ENDP

000022  0000              DCW      0x0000
                  |L21.36|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_WRPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_WRPConfig PROC
;;;694      */
;;;695    void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;696    { 
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;697      FLASH_Status status = FLASH_COMPLETE;
;;;698      
;;;699      /* Check the parameters */
;;;700      assert_param(IS_OB_WRP(OB_WRP));
;;;701      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;702        
;;;703      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;704    
;;;705      if(status == FLASH_COMPLETE)
00000a  2808              CMP      r0,#8
00000c  d106              BNE      |L22.28|
;;;706      { 
;;;707        if(NewState != DISABLE)
;;;708        {
;;;709          *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
00000e  4804              LDR      r0,|L22.32|
;;;710        }
;;;711        else
;;;712        {
;;;713          *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
000010  8801              LDRH     r1,[r0,#0]
000012  b10c              CBZ      r4,|L22.24|
000014  4399              BICS     r1,r1,r3              ;709
000016  e000              B        |L22.26|
                  |L22.24|
000018  4319              ORRS     r1,r1,r3
                  |L22.26|
00001a  8001              STRH     r1,[r0,#0]
                  |L22.28|
;;;714        }
;;;715      }
;;;716    }
00001c  bd10              POP      {r4,pc}
;;;717    
                          ENDP

00001e  0000              DCW      0x0000
                  |L22.32|
                          DCD      0x40023c16

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;186      */
;;;187    void FLASH_PrefetchBufferCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L23.24|
;;;188    {
;;;189      /* Check the parameters */
;;;190      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;191      
;;;192      /* Enable or disable the Prefetch Buffer */
;;;193      if(NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;194      {
;;;195        FLASH->ACR |= FLASH_ACR_PRFTEN;
;;;196      }
;;;197      else
;;;198      {
;;;199        FLASH->ACR &= (~FLASH_ACR_PRFTEN);
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L23.14|
000008  f4407080          ORR      r0,r0,#0x100          ;195
00000c  e001              B        |L23.18|
                  |L23.14|
00000e  f4207080          BIC      r0,r0,#0x100
                  |L23.18|
000012  6008              STR      r0,[r1,#0]            ;195
;;;200      }
;;;201    }
000014  4770              BX       lr
;;;202    
                          ENDP

000016  0000              DCW      0x0000
                  |L23.24|
                          DCD      0x40023c00

                          AREA ||i.FLASH_ProgramByte||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramByte PROC
;;;578      */
;;;579    FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
000000  b530              PUSH     {r4,r5,lr}
;;;580    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;581      FLASH_Status status = FLASH_COMPLETE;
;;;582    
;;;583      /* Check the parameters */
;;;584      assert_param(IS_FLASH_ADDRESS(Address));
;;;585    
;;;586      /* Wait for last operation to be completed */
;;;587      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;588      
;;;589      if(status == FLASH_COMPLETE)
00000a  2808              CMP      r0,#8
00000c  d111              BNE      |L24.50|
;;;590      {
;;;591        /* if the previous operation is completed, proceed to program the new data */
;;;592        FLASH->CR &= CR_PSIZE_MASK;
00000e  4b09              LDR      r3,|L24.52|
000010  6818              LDR      r0,[r3,#0]
000012  f4207040          BIC      r0,r0,#0x300
000016  6018              STR      r0,[r3,#0]
;;;593        FLASH->CR |= FLASH_PSIZE_BYTE;
000018  6818              LDR      r0,[r3,#0]
00001a  6018              STR      r0,[r3,#0]
;;;594        FLASH->CR |= FLASH_CR_PG;
00001c  6818              LDR      r0,[r3,#0]
00001e  f0400001          ORR      r0,r0,#1
000022  6018              STR      r0,[r3,#0]
;;;595      
;;;596        *(__IO uint8_t*)Address = Data;
000024  7025              STRB     r5,[r4,#0]
;;;597            
;;;598        /* Wait for last operation to be completed */
;;;599        status = FLASH_WaitForLastOperation();
000026  f7fffffe          BL       FLASH_WaitForLastOperation
;;;600    
;;;601        /* if the program operation is completed, disable the PG Bit */
;;;602        FLASH->CR &= (~FLASH_CR_PG);
00002a  6819              LDR      r1,[r3,#0]
00002c  f0210101          BIC      r1,r1,#1
000030  6019              STR      r1,[r3,#0]
                  |L24.50|
;;;603      } 
;;;604    
;;;605      /* Return the Program Status */
;;;606      return status;
;;;607    }
000032  bd30              POP      {r4,r5,pc}
;;;608    
                          ENDP

                  |L24.52|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramDoubleWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramDoubleWord PROC
;;;464      */
;;;465    FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;466    {
000002  4606              MOV      r6,r0
000004  4615              MOV      r5,r2
;;;467      FLASH_Status status = FLASH_COMPLETE;
;;;468    
;;;469      /* Check the parameters */
;;;470      assert_param(IS_FLASH_ADDRESS(Address));
;;;471    
;;;472      /* Wait for last operation to be completed */
;;;473      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;474      
;;;475      if(status == FLASH_COMPLETE)
00000a  2808              CMP      r0,#8
00000c  d114              BNE      |L25.56|
;;;476      {
;;;477        /* if the previous operation is completed, proceed to program the new data */
;;;478        FLASH->CR &= CR_PSIZE_MASK;
00000e  4c0b              LDR      r4,|L25.60|
000010  6820              LDR      r0,[r4,#0]
000012  f4207040          BIC      r0,r0,#0x300
000016  6020              STR      r0,[r4,#0]
;;;479        FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
000018  6820              LDR      r0,[r4,#0]
00001a  f4407040          ORR      r0,r0,#0x300
00001e  6020              STR      r0,[r4,#0]
;;;480        FLASH->CR |= FLASH_CR_PG;
000020  6820              LDR      r0,[r4,#0]
000022  f0400001          ORR      r0,r0,#1
000026  6020              STR      r0,[r4,#0]
;;;481      
;;;482        *(__IO uint64_t*)Address = Data;
000028  6035              STR      r5,[r6,#0]
00002a  6073              STR      r3,[r6,#4]
;;;483            
;;;484        /* Wait for last operation to be completed */
;;;485        status = FLASH_WaitForLastOperation();
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;486    
;;;487        /* if the program operation is completed, disable the PG Bit */
;;;488        FLASH->CR &= (~FLASH_CR_PG);
000030  6821              LDR      r1,[r4,#0]
000032  f0210101          BIC      r1,r1,#1
000036  6021              STR      r1,[r4,#0]
                  |L25.56|
;;;489      } 
;;;490      /* Return the Program Status */
;;;491      return status;
;;;492    }
000038  bd70              POP      {r4-r6,pc}
;;;493    
                          ENDP

00003a  0000              DCW      0x0000
                  |L25.60|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;540      */
;;;541    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b530              PUSH     {r4,r5,lr}
;;;542    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;543      FLASH_Status status = FLASH_COMPLETE;
;;;544    
;;;545      /* Check the parameters */
;;;546      assert_param(IS_FLASH_ADDRESS(Address));
;;;547    
;;;548      /* Wait for last operation to be completed */
;;;549      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;550      
;;;551      if(status == FLASH_COMPLETE)
00000a  2808              CMP      r0,#8
00000c  d113              BNE      |L26.54|
;;;552      {
;;;553        /* if the previous operation is completed, proceed to program the new data */
;;;554        FLASH->CR &= CR_PSIZE_MASK;
00000e  4b0a              LDR      r3,|L26.56|
000010  6818              LDR      r0,[r3,#0]
000012  f4207040          BIC      r0,r0,#0x300
000016  6018              STR      r0,[r3,#0]
;;;555        FLASH->CR |= FLASH_PSIZE_HALF_WORD;
000018  6818              LDR      r0,[r3,#0]
00001a  f4407080          ORR      r0,r0,#0x100
00001e  6018              STR      r0,[r3,#0]
;;;556        FLASH->CR |= FLASH_CR_PG;
000020  6818              LDR      r0,[r3,#0]
000022  f0400001          ORR      r0,r0,#1
000026  6018              STR      r0,[r3,#0]
;;;557      
;;;558        *(__IO uint16_t*)Address = Data;
000028  8025              STRH     r5,[r4,#0]
;;;559            
;;;560        /* Wait for last operation to be completed */
;;;561        status = FLASH_WaitForLastOperation();
00002a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;562    
;;;563        /* if the program operation is completed, disable the PG Bit */
;;;564        FLASH->CR &= (~FLASH_CR_PG);
00002e  6819              LDR      r1,[r3,#0]
000030  f0210101          BIC      r1,r1,#1
000034  6019              STR      r1,[r3,#0]
                  |L26.54|
;;;565      } 
;;;566      /* Return the Program Status */
;;;567      return status;
;;;568    }
000036  bd30              POP      {r4,r5,pc}
;;;569    
                          ENDP

                  |L26.56|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;502      */
;;;503    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b530              PUSH     {r4,r5,lr}
;;;504    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;505      FLASH_Status status = FLASH_COMPLETE;
;;;506    
;;;507      /* Check the parameters */
;;;508      assert_param(IS_FLASH_ADDRESS(Address));
;;;509    
;;;510      /* Wait for last operation to be completed */
;;;511      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;512      
;;;513      if(status == FLASH_COMPLETE)
00000a  2808              CMP      r0,#8
00000c  d113              BNE      |L27.54|
;;;514      {
;;;515        /* if the previous operation is completed, proceed to program the new data */
;;;516        FLASH->CR &= CR_PSIZE_MASK;
00000e  4b0a              LDR      r3,|L27.56|
000010  6818              LDR      r0,[r3,#0]
000012  f4207040          BIC      r0,r0,#0x300
000016  6018              STR      r0,[r3,#0]
;;;517        FLASH->CR |= FLASH_PSIZE_WORD;
000018  6818              LDR      r0,[r3,#0]
00001a  f4407000          ORR      r0,r0,#0x200
00001e  6018              STR      r0,[r3,#0]
;;;518        FLASH->CR |= FLASH_CR_PG;
000020  6818              LDR      r0,[r3,#0]
000022  f0400001          ORR      r0,r0,#1
000026  6018              STR      r0,[r3,#0]
;;;519      
;;;520        *(__IO uint32_t*)Address = Data;
000028  6025              STR      r5,[r4,#0]
;;;521            
;;;522        /* Wait for last operation to be completed */
;;;523        status = FLASH_WaitForLastOperation();
00002a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;524    
;;;525        /* if the program operation is completed, disable the PG Bit */
;;;526        FLASH->CR &= (~FLASH_CR_PG);
00002e  6819              LDR      r1,[r3,#0]
000030  f0210101          BIC      r1,r1,#1
000034  6019              STR      r1,[r3,#0]
                  |L27.54|
;;;527      } 
;;;528      /* Return the Program Status */
;;;529      return status;
;;;530    }
000036  bd30              POP      {r4,r5,pc}
;;;531    
                          ENDP

                  |L27.56|
                          DCD      0x40023c10

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;171      */
;;;172    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4901              LDR      r1,|L28.8|
;;;173    {
;;;174      /* Check the parameters */
;;;175      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;176      
;;;177      /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
;;;178      *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
000002  7008              STRB     r0,[r1,#0]
;;;179    }
000004  4770              BX       lr
;;;180    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x40023c00

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;305      */
;;;306    void FLASH_Unlock(void)
000000  4805              LDR      r0,|L29.24|
;;;307    {
;;;308      if((FLASH->CR & FLASH_CR_LOCK) != RESET)
000002  6800              LDR      r0,[r0,#0]
000004  2800              CMP      r0,#0
000006  da05              BGE      |L29.20|
;;;309      {
;;;310        /* Authorize the FLASH Registers access */
;;;311        FLASH->KEYR = FLASH_KEY1;
000008  4803              LDR      r0,|L29.24|
00000a  4904              LDR      r1,|L29.28|
00000c  380c              SUBS     r0,r0,#0xc
00000e  6001              STR      r1,[r0,#0]
;;;312        FLASH->KEYR = FLASH_KEY2;
000010  4903              LDR      r1,|L29.32|
000012  6001              STR      r1,[r0,#0]
                  |L29.20|
;;;313      }  
;;;314    }
000014  4770              BX       lr
;;;315    
                          ENDP

000016  0000              DCW      0x0000
                  |L29.24|
                          DCD      0x40023c10
                  |L29.28|
                          DCD      0x45670123
                  |L29.32|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=2

                  FLASH_WaitForLastOperation PROC
;;;1027     */
;;;1028   FLASH_Status FLASH_WaitForLastOperation(void)
000000  b500              PUSH     {lr}
;;;1029   { 
;;;1030     __IO FLASH_Status status = FLASH_COMPLETE;
;;;1031      
;;;1032     /* Check for the FLASH Status */
;;;1033     status = FLASH_GetStatus();
000002  bf00              NOP      
                  |L30.4|
000004  f7fffffe          BL       FLASH_GetStatus
;;;1034   
;;;1035     /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
;;;1036        Even if the FLASH operation fails, the BUSY flag will be reset and an error
;;;1037        flag will be set */
;;;1038     while(status == FLASH_BUSY)
000008  2801              CMP      r0,#1
00000a  d0fb              BEQ      |L30.4|
;;;1039     {
;;;1040       status = FLASH_GetStatus();
;;;1041     }
;;;1042     /* Return the operation status */
;;;1043     return status;
;;;1044   }
00000c  bd00              POP      {pc}
;;;1045   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_flash.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f4xx_flash_c_a2a150d6____REV16|
#line 114 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f4xx_flash_c_a2a150d6____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f4xx_flash_c_a2a150d6____REVSH|
#line 128
|__asm___17_stm32f4xx_flash_c_a2a150d6____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
